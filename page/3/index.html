<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="凹凸豆的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="凹凸豆的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ccbeango">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>凹凸豆的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">凹凸豆的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">那天，黄昏，开始飘起来白雪</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Redis知识点总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-05 16:03:10" itemprop="dateCreated datePublished" datetime="2019-03-05T16:03:10+08:00">2019-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-27 17:56:53" itemprop="dateModified" datetime="2019-12-27T17:56:53+08:00">2019-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis知识点总结"><a href="#Redis知识点总结" class="headerlink" title="Redis知识点总结"></a>Redis知识点总结</h1><ol>
<li><p>Redis的全称是Remote Dictionary Server，本质上是一个<code>key-value</code>类型的内存数据库，它支持的<code>value</code>类型有字符串<code>String</code>、哈希<code>Hash</code>、无序集合<code>Set</code>、有序集合<code>Sorted Set</code>、列表<code>List</code>。这些数据类型都支持push/pop、add/remove、取交集并集差集以及更丰富的操作，而且这些操作类型都是原子性的。与memcached类似，将数据都加载至内存中进行操作，不同之处在于redis会周期性地将更新数据写入到磁盘中。</p>
</li>
<li><p>Redis支持的数据类型</p>
<ul>
<li>String：用于管理redis字符串值；string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<code>set key value</code>、<code>get key value</code></li>
<li>Hash：是一个<code>String</code>类型的<code>field</code>和<code>value</code>的映射表，适合用于存储对象，每个<code>hash</code>可存储2^32-1个键值对；<code>HMSET hashkey key1 value1 key2 value2 ...</code>、<code>HGETALL hashkey</code></li>
<li>List：列表是一个简单的字符串列表，按照插入顺序进行排序，可以添加一个元素到列表的头部或者尾部；<code>lpush listkey  value</code>、<code>rpush  listkey  value</code>、<code>lpop listkey</code>、<code>rpop listkey</code></li>
<li>Set：是 String 类型的无序集合，集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 0(1)。<code>SADD key member1 [member2]</code>、<code>SMEMBERS key</code></li>
<li>zSet：有序集合和集合一样也是string类型元素的集合,且不允许重复的成员；不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是0(1)。</li>
</ul>
</li>
<li><p>Redis持久化的含义，Redis持久化的方式以及优缺点：</p>
<p>​    Redis持久化就是把内存中的数据写入到磁盘中，防止服务器宕机时数据丢失。</p>
<p>Redis持久化支持两种方式：RDB（默认）和AOF</p>
<ul>
<li><p>RDB：是<code>Redis Database</code>的缩写，在指定的时间间隔对数据进行快照存储。</p>
<p>功能核心函数是<code>rdbSave()</code>和<code>rdbLoad()</code></p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9301.png" alt=""></p>
<p><strong>优点：</strong></p>
<ol>
<li>RDB数据非常紧凑，它保存了某个时间点的数据集，非常适用于数据集的备份；</li>
<li>RDB是个紧凑单一的文件，非常适用于数据的灾难恢复</li>
<li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能</li>
<li>与AOF相比，在恢复大数据的时候，RDB方式更快一些</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>如果希望Redis在意外停止工作时损失数据最少的话，RDB不合适，它要保存一个完整的数据集是一个比较繁重的工作</li>
<li>RDB需要经常fork子进程来保存数据到硬盘上，当数据集比较大时，fork过程是非常耗时的，可能会导致Redis在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒，AOF也需要fork，但是可以调节重写日志文件的频率来提高数据集的耐久度</li>
</ul>
</li>
<li><p>AOF是<code>Append-only file</code>的缩写</p>
<p>AOF持久化方式是记录每次对服务器的写操作；Redis重启的时候优先载入AOF文件对数据进行恢复，通常情况下，AOF保存的数据集要比RDB保存的完整。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9302.png" alt=""></p>
<p><strong>优点：</strong></p>
<ul>
<li>使用AOF会让Redis数据更加耐久，可以使用不容的<code>fsync</code>策略进行AOF操作，无fsync、每秒fsync、每次写操作时fsync</li>
<li>Redis文件是一个只进行追加的日志文件，所以不需要写入seek（？？？）</li>
<li>AOF文件有序地保存了对数据库的所有写入操作，存储结构是Redis通讯协议RESP的命令文本存储，导入导出方便。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对于相同的数据集来说，AOF文件体积通常大于RDB文件体积</li>
<li>根据所使用的fsync策略，AOF速度可能会慢于RDB</li>
</ul>
<p>RDB和AOF的使用，建议同时使用两种持久化功能。</p>
<p>每当服务器执行（定时）任务或调用<code>flushAppendOnlyFile()</code>时都会调用AOF，此时AOF会做写入和保存两个操作：</p>
<ul>
<li>WRITE：根据条件，将<code>aof_buf</code>的缓存写入到AOF文件；</li>
<li>SAVE：根据条件，调用<code>fsync()</code>或<code>fdatasync()</code>函数，将AOF文件保存到磁盘中。</li>
</ul>
</li>
</ul>
</li>
<li><p>RESP的解释：RESP是Redis客户端和服务端之间采取的一种名为RESP(Redis Serialization Protocol)的序列化协议。</p>
<p>它的特点是：容易实现、解析快、可读性高。</p>
<p>RESP主要包含的几种数据类型是：单行回复（简单字符串）、整数、数组、错误信息、多行字符串。Redis客户端向服务端发送一组由执行命令组成的字符串数组，服务端根据不同的命令回复不同类型的数据，但协议的每部分都是以”\r\n”(CRLF)结尾的。？？？另外 RESP 是二进制安全的，不需要处理从一个进程到另一个进程的传输，因为它使用了前缀长度进行传输。</p>
<p>在RESP中，一些数据的类型通过第一个字节进行判断：</p>
<ul>
<li>单行回复：回复的第一个字节是“+”</li>
<li>整数：回复的第一个字节是“:”</li>
<li>错误信息：回复的第一个字节是“-”</li>
<li>数组：回复的第一个字节是“*”</li>
<li>多行字符串：回复的第一个字节是 “$”</li>
</ul>
</li>
<li><p>达到Redis使用上限：如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
</li>
<li><p>Redis的数据淘汰策略：</p>
<ul>
<li>noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。</li>
<li>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</li>
<li>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
</li>
<li><p>缓存穿透：一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key，请求量很大，每次查询都要到数据库进行查询，就会对后端系统造成很大的压力，这就叫做缓存穿透。</p>
<p>避免方法：</p>
<p>1）对查询为空的情况下也进行缓存，缓存时间设置的短一些，或者该key对应的数据插入了数据库之后再清楚缓存；</p>
<p>2）对一定不存的key进行过滤，可以把所有的可能存在的key放到一个足够大的Bitmap中，查询时通过该bitmap过滤。</p>
</li>
<li><p>缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，发生大量的缓存穿透，会给后端系统带来很大压力。导致系统崩溃。</p>
<p>避免方法：</p>
<ul>
<li><p>加锁排队：通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如<a href="http://lib.csdn.net/base/redis" target="_blank" rel="noopener">Redis</a>的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>
</li>
<li><p>数据预热： 可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key。</p>
</li>
<li><p>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
</li>
<li><p>key设置不同的过期时间，让缓存失效的时间点尽量均匀</p>
</li>
<li><p>缓存永不过期：包含两层含义，(1) 从缓存上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。 (2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期。</p>
<p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9303.png" alt=""></p>
</li>
</ul>
</li>
<li><p>Redis的适用场景：</p>
<ol>
<li>会话缓存</li>
<li>页面缓存</li>
<li>队列</li>
<li>排行榜/计数器</li>
<li>发布/订阅</li>
</ol>
</li>
<li><p>Redis分布式锁：先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p>
</li>
<li><p>Redis异步队列：一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<p>缺点：</p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<p><strong>能不能生产一次消费多次呢？</strong></p>
<p>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
</li>
<li><p>Redis哈希槽：Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
</li>
<li><p>Redis管道：一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
</li>
<li><p>Redis回收工作：</p>
</li>
<li><p>理解Redis事务：事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务可以一次执行多个命令，并且事务有以下保证：</p>
<ul>
<li>批量操作在执行MULTI之后和执行EXEC之前会被放入队列缓存</li>
<li>收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<p>事务执行都会经过三个阶段：1.开始事务；2.命令入队；3.执行事务。</p>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
</li>
<li><p>Redis架构模式以及特点：</p>
<p>1.<strong>单机版：</strong></p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9304.png" alt=""></p>
<p>​    特点：简单</p>
<p>​    问题：1.内存容量有限； 2.处理能力有限 ；3.无法高可用。</p>
<p><strong>2.主从复制：</strong></p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9305.png" alt=""></p>
<p>​    Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>​    特点：1.master/slave角色；2.master/slave数据相同；3.降低master的读压力，转交给slave库；</p>
<p>​    问题：无法保证高可用；没有解决 master 写的压力。</p>
<p><strong>3.哨兵：</strong></p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9306.png" alt=""></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<p>监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。</p>
<p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
<p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作</p>
<p>特点：</p>
<p>1、保证高可用</p>
<p>2、监控各个节点</p>
<p>3、自动故障迁移</p>
<p>缺点：主从模式，切换需要时间丢数据；没有解决 master 写的压力</p>
<p><strong>4.集群（proxy 型）：</strong></p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9307.png" alt=""></p>
<p>​    </p>
<p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：</p>
<ul>
<li>多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </li>
<li>支持失败节点自动删除</li>
<li>后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</li>
</ul>
<p>缺点：增加了新的 proxy，需要维护其高可用。</p>
<p><strong>5.集群（直连型）：</strong></p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/Redis/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9308.png" alt=""></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<ul>
<li>无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源隔离性较差，容易出现相互影响的情况。</li>
<li>数据通过异步复制,不保证数据的强一致性 </li>
</ul>
</li>
</ol>
<ol start="17">
<li>Redis和MongoDB的区别：就Redis和MongoDB来说，大家一般称之为Redis缓存、MongoDB数据库。这也是有道有理有根据的，Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活。</li>
<li>Redis解决秒杀/抢红包等高并发事务活动<ol>
<li>秒杀开始前30分钟把秒杀库存从数据库同步到Redis Sorted Set</li>
<li>用户秒杀库存放入秒杀限制数长度的Sorted Set</li>
<li>秒杀到指定秒杀数后，Sorted Set不在接受秒杀请求，并显示返回标识</li>
<li>秒杀活动完全结束后，同步Redis数据到数据库，秒杀正式结束</li>
</ol>
</li>
</ol>
<h2 id="Redis如何保持和Mysql数据库数据一致"><a href="#Redis如何保持和Mysql数据库数据一致" class="headerlink" title="Redis如何保持和Mysql数据库数据一致"></a>Redis如何保持和Mysql数据库数据一致</h2><p><strong>1. MySQL持久化数据,Redis只读数据</strong></p>
<p>Redis在启动之后，从数据库加载数据。读请求：不要求强一致性的读请求，走redis，要求强一致性的直接从mysql读取；写请求：数据首先都写到数据库，之后更新redis（先写redis再写mysql，如果写入失败事务回滚会造成redis中存在脏数据）。</p>
<p><strong>2.MySQL和Redis处理不同的数据类型</strong></p>
<p>MySQL处理实时性数据，例如金融数据、交易数据</p>
<p>Redis处理实时性要求不高的数据，例如网站最热贴排行榜，好友列表等</p>
<p>在并发不高的情况下，读操作优先读取redis，不存在的话就去访问MySQL，并把读到的数据写回Redis中；写操作的话，直接写MySQL，成功后再写入Redis(可以在MySQL端定义CRUD触发器，在触发CRUD操作后写数据到Redis，也可以在Redis端解析binlog，再做相应的操作)</p>
<p>在并发高的情况下，读操作和上面一样，写操作是异步写，写入Redis后直接返回，然后定期写入MySQL</p>
<hr>
<p><strong>几个例子：</strong></p>
<ol>
<li><p>当更新数据时，如更新某商品的库存，当前商品的库存是100，现在要更新为99，先更新数据库更改成99，然后删除缓存，发现删除缓存失败了，这意味着数据库存的是99，而缓存是100，这导致数据库和缓存不一致。</p>
<p>解决方法： </p>
<pre><code>这种情况应该是先删除缓存，然后在更新数据库，如果删除缓存失败，那就不要更新数据库，如果说删除缓存成功，而更新数据库失败，那查询的时候只是从数据库里查了旧的数据而已，这样就能保持数据库与缓存的一致性。</code></pre></li>
<li><p>在高并发的情况下，如果当删除完缓存的时候，这时去更新数据库，但还没有更新完，另外一个请求来查询数据，发现缓存里没有，就去数据库里查，还是以上面商品库存为例，如果数据库中产品的库存是100，那么查询到的库存是100，然后插入缓存，插入完缓存后，原来那个更新数据库的线程把数据库更新为了99，导致数据库与缓存不一致的情况</p>
<p>解决方法：<br>遇到这种情况，可以用队列的去解决这个问，创建几个队列，如20个，根据商品的ID去做hash值，然后对队列个数取摸，当有数据更新请求时，先把它丢到队列里去，当更新完后在从队列里去除，如果在更新的过程中，遇到以上场景，先去缓存里看下有没有数据，如果没有，可以先去队列里看是否有相同商品ID在做更新，如果有也把查询的请求发送到队列里去，然后同步等待缓存更新完成。<br>这里有一个优化点，如果发现队列里有一个查询请求了，那么就不要放新的查询操作进去了，用一个while（true）循环去查询缓存，循环个200MS左右，如果缓存里还没有则直接取数据库的旧数据，一般情况下是可以取到的。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/JavaScript/JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%A7%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/JavaScript/JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%A7%E8%B4%A8/" class="post-title-link" itemprop="url">JS中原型对象的性质</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-22 16:20:10" itemprop="dateCreated datePublished" datetime="2019-01-22T16:20:10+08:00">2019-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-27 17:56:53" itemprop="dateModified" datetime="2019-12-27T17:56:53+08:00">2019-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JS中原型对象的性质"><a href="#JS中原型对象的性质" class="headerlink" title="JS中原型对象的性质"></a>JS中原型对象的性质</h1><blockquote>
<p>摘自 《JavaScript高级程序设计》</p>
</blockquote>
<h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个<code>prototype</code>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会获得一个<code>constructor</code>（构造函数）属性，这个属性包含一个指向<code>prototype</code>属性所在函数的指针。如<code>Person.prototype.constructor</code>指向<code>Person</code>。而通过这个构造函数，还可以继续为原型对象添加其他属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从<code>Object</code>继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5中管这个指针叫<code>[[Prototype]]</code>。 虽然在脚本中没有标准的方式访问<code>[[Prototype]]</code> ， 但Firefox、Safari和Chrome在每个对象上都支持一个属性 <code>_proto_</code> ;而在其他实现中，这个属性对脚本则是完全不可见的。==不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。==</p>
<p>​    以前面使用<code>Person</code>构造函数和<code>Person.prototype</code>创建实例的代码为例，下图展示了各个对象之间的关系。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%A7%E8%B4%A801.jpg" alt=""></p>
<p>​    上图展示了<code>Person</code>构造函数、<code>Person</code>的原型属性以及<code>Person</code>现有的两个实例之间的关系。 在此，<code>Person.prototype</code> 指向了原型对象，而 <code>Person.prototype.constructor</code>又指回了 <code>Person</code>。 原型对象中除了包含<code>constructor</code>属性之外，还包括后来添加的其他属性。<code>Person</code>的每个实例—— <code>person1</code>和<code>person2</code>都包含一个内部属性，该属性仅仅指向了<code>Person.prototype</code> ；换句话说，<strong>它们与构造函数没有直接的关系。</strong>此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以通过调用<code>person1.sayName()</code>。这是通过查找对象属性的过程来实现的。</p>
<p>​    虽然在所有实现中都无法访问到<code>[[Prototype]]</code>，但可以通过<code>isPrototypeOf()</code>方法来确定对象之 间是否存在这种关系。从本质上讲，如果<code>[[Prototype]]</code>指向调用<code>isPrototypeOf()</code>方法的对象 (<code>Person.prototype</code>)，那么这个方法就返回true，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(person1); <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeOf(person2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这里，用原型对象的<code>isPrototypeOf()</code>方法测试了<code>person1</code>和<code>person2</code>。因为它们内部都有一个指向<code>Person.prototype</code>的指针，因此都返回了<code>true</code>。</p>
<p>在ES5中增加了一个新方法，叫<code>Object.getPrototypeOf()</code>，在所有支持的视线中，这个方法返回<code>[[Prototype]]</code>的值。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1).name; <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure>

<p>​    这里的第一行代码只是确定<code>Object.getPrototypeOf()</code>返回的对象实际就是这个对象的原型。 第二行代码取得了原型对象中<code>name</code>属性的值，也就是”Nicholas”。使用<code>Object.getPrototypeOf ()</code>可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。 </p>
<p>​    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用<code>personl. sayName()</code>的时候，会先后执行两次搜索。首先，解析器会问：“实例<code>personl</code>有<code>sayName</code>属性吗？ ”答：“没有。”然后，它继续搜索，再问：“<code>personl</code>的原型有<code>sayName</code>属性吗？ ”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用<code>person.sayName()</code>时，将会重现相同的搜索过程，得到相同的结果。而<strong>这正是多个对象实例共享原型所保存的属性和方法的基本原理。</strong></p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// Greg --来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// Nicholas -- 来自原型</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>person1</code>的<code>name</code>被一个新值给屏蔽了。但无论访问<code>personl.name</code>还是访问<code>person2.name</code>都能够正常地返回值，即分别是”Greg”(来自对象实例）和”Nicholas”(来自原型)。 当在 <code>console.log ()</code>中访问<code>person1.name</code>时，需要读取它的值，因此就会在这个实例上搜索一个名为<code>name</code> 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问<code>person2.name</code>时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了<code>name</code>属性。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用delete操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line"></span><br><span class="line">person1.name; <span class="comment">// Greg -- 来自实例</span></span><br><span class="line">person2.name; <span class="comment">// Nicholas -- 来自原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">person1.name; <span class="comment">// Nicholas --来自原型</span></span><br></pre></td></tr></table></figure>

<p>使用<code>delete</code>操作符删除了 <code>person1.name</code>,之前它保存的”Greg” 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中<code>name</code>属性的连接。因此，接下来再调用 <code>person1.name</code>时，返回的就是原型中<code>name</code>属性的值了。</p>
<p>使用<code>hasOwnProperty()</code>方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从<code>Object</code>继承来的）只在给定属性存在于对象实例中时，才会返回<code>true</code>。来看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.hasOwnProperty(<span class="string">"name"</span>);  <span class="comment">//false</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// Greg -- 来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// Nicholas --来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//  Nicholas --来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>通过使用<code>hasOwnProperty()</code>方法，可以很清楚地看到何时访问的是实力属性，何时访问的是原型属性。调用<code>person1.hasOwnProperty(&quot;name&quot;)</code>时，只有当<code>person1</code>重写<code>name</code>属性后才会返回<code>true</code>，因为只有这时<code>name</code>才是一个实例属性，而非原型对象。下图展示了上面例子不同情况下的实例与原型的关系（为简单起见，图中省略了与<code>Person</code>构造函数的关系）。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%A7%E8%B4%A802.jpg" alt=""></p>
<p><strong>注意：</strong>ES5 的 <code>Object.getOwnPropertyDescriptor()</code>方法只能用于实例属 性，要取得原型属性的描述符，必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>方法。</p>
<h2 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h2><p>有两种方式使用<code>in</code>操作符：单独使用和在<code>for-in</code>中使用。</p>
<p>单独使用时，<code>in</code>操作符会在通过对象能够访问给定属性时返回<code>true</code>，无论实例存在于实例中还是原型中。例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.hasOwnProperty(<span class="string">"name"</span>);  <span class="comment">//false</span></span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> person1; <span class="comment">// true</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// Greg -- 来自实例</span></span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> person1; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中，<code>name</code>要么直接在对象上访问到，要么通过原型访问到。调用<code>name in person1</code>始终返回<code>true</code>，无论是在原型还是实例中。同事使用<code>hasOwnProperty()</code>方法和<code>in</code>操作符，就可以确定属性到底是在对象中还是在原型中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只要<code>in</code>操作符返回<code>true</code>，而<code>hasOwnProperty()</code>返回<code>false</code>，就可以确定属性是原型中的属性。</p>
<p>在使用<code>for-in</code>循环时，返回的是所有能够通过对象访问的、可枚举的属性，切中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将<code>[[Enmuerable]]</code>标记为<code>false</code>的属性）的实例属性也会在<code>for-in</code>循环中返回。因为根据规定，所有开发人员定义的属性都是可枚举的。</p>
<h2 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h2><p>前面的例子每添加一个属性和方法就要敲一遍<code>Person.prototype</code>。为减少不必要输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含属性和方法的对象字面量来重写整个原型对象，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job:  <span class="string">"Software Engineer"</span>;</span><br><span class="line">	sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们将<code>Person.prototype</code>设置为等于一个以对象字面量形式创建的新对象。 最终结果相同，但有一个例外：<code>constructor</code>属性不再指向<code>Person</code>了。前面曾经介绍过，==每创建一个函数，就会同时创建它的<code>prototype</code>对象，这个对象也会自动获得<code>constructor</code>属性。==而我们在这里使用的语法，==本质上完全重写了默认的<code>prototype</code>对象==，因此constructor属性也就变成了新对象的<code>constructor</code>属性（指向Object构造函数），不再指向<code>Person</code>函数。此时，尽管instanceof 操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在此，用<code>instanceof</code>操作符测试<code>Object</code>和<code>Person</code>仍然返回<code>true</code>，但<code>constructor</code>属性则等于<code>Object</code>而不等于<code>Person</code> 了。如果<code>constructor</code>的值真的很重要，可以像下面这样特意将它设 置回适当的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job:  <span class="string">"Software Engineer"</span>;</span><br><span class="line">	sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码特意包含了一个<code>constructor</code>属性，并将它设置为<code>Person</code>，从而确保了通过该属性能够访问到适当的值。</p>
<p>注意，以这种方式重设<code>constructor</code>属性，会导致它的<code>[[Enmuerable]]</code>特性被设置为<code>true</code>。默认情况下，原生的<code>constructor</code>属性是不可枚举的。</p>
<p>因此，如果是ES5可以试试，<code>Object.defineProperty()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注：ES5其实可以使用<code>Object.create()</code>方法：该<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">方法</a>创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。ES5之前实现继承时常用的方法。</p>
<h2 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h2><p>由于原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi(); <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure>

<p>以上代码先创建了<code>Person</code>的一个实例，并将其保存在<code>person</code>中。然后，下一条语句在<code>Person.prototype</code>中添加了一个方法<code>sayHi()</code>。即使<code>person</code>实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用<code>person. sayHi()</code>时，首先会在实例中搜索名为<code>sayHi</code>的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的<code>sayHi</code>属性并返回保存在那里的函数。</p>
<p> 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的<code>[[Prototype]]</code>指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：==实例中的指针仅指向原型，而不指向构造函数。==看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName();   <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们先创建了<code>Person</code>的一个实例，然后又重写了其原型对象。然后在调用<code>friend.sayName()</code>时发生了错误，因为<code>friend</code>指向的原型中不包含以该名字命名的属性。过程的内幕如下图：</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%A7%E8%B4%A803.jpg" alt=""></p>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p>
<h2 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h2><p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（<code>Object</code>、<code>Array</code>、<code>String</code>等）都在其构造函数的原型上定义了方法。</p>
<p>例如在<code>Array.prototype</code>中可以找到<code>sort()</code>方法，而在<code>String.prototype</code>中可以找到<code>substring()</code>方法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。</p>
<p>尽管可以这样做，但是不推荐在产品化的程序中修改原生对象的原型。</p>
<h2 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h2><p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。 原型模式的最大问题是由其共享的本性所导致的。 </p>
<p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒 也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属 性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    friends : ["Shelby", "Court"],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在此，<code>Person.prototype</code>对象有一个名为<code>friends</code>的属性，该属性包含一个字符串数组。然后， 创建了<code>Person</code>的两个实例。接着，修改了<code>person1.friends</code>引用的数组，向数组中添加了一个字符 串。由于<code>friends</code>数组存在于<code>Person.prototype</code>而非<code>person1</code>中，所以刚刚提到的修改也会通过 <code>person2. friends</code> (与<code>personl.friends</code>指向同一个数组）反映出来。假如我们的初衷就是像这样 在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/JavaScript/JS%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/JavaScript/JS%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">JS的基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-07 17:20:10" itemprop="dateCreated datePublished" datetime="2019-01-07T17:20:10+08:00">2019-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-27 17:56:53" itemprop="dateModified" datetime="2019-12-27T17:56:53+08:00">2019-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>JS区分大小写；函数名不能适用<code>typeof</code>，它是一个关键字。</p>
</li>
<li><p>标识符就是指变量、函数、属性的名字，或者函数的参数。</p>
</li>
<li><p>JS注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是多行注释</span></span><br><span class="line"><span class="comment">* (块级)注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>严格模式：为<code>JavaScript</code>定义了一种不同的解析与执行模式。是ES5引入的一个概念，处理了ES3的一些不确定行为。整个脚本中使用或函数内部使用，分别加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个脚本中，在顶部加</span></span><br><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="comment">// 函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>严格模式主要限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能适用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能适用前缀0表示八进制，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会再它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code>和<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能适用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字，如<code>protected</code>、<code>static</code>、<code>interface</code></li>
</ul>
<p>尤其注意<code>this</code>的限制，ES6模块中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码中使用<code>this</code>。</p>
</li>
<li><p>JS语句以分号结尾，如果分号省略，则由解析器确定语句的结尾；建议任何时候都不要省略分号。</p>
</li>
<li><p>JS变量类型是松散类型的，即可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符而已。</p>
</li>
<li><p>JS有5种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>;还有一种复杂的数据类型<code>Object</code>，它本质上是由一组无序的名值对组成的。</p>
</li>
<li><p><code>typeof</code>是操作符，而不是函数。它用来检测给定变量的数据类型。<code>typeof</code>可能返回的字符串：</p>
<ul>
<li>“undefined”：如果这个值未定义；</li>
<li>“boolean”：如果这个值是布尔值；</li>
<li>“string”：如果这个值是字符串；</li>
<li>“number”：如果这个值是数值；</li>
<li>“object”：如果这个值是对象或<code>null</code>；<code>null</code>会被认为是一个空的对象引用</li>
<li>“function”：如果这个值是函数。</li>
</ul>
</li>
<li><p><code>Undefined</code>类型只有一个值，即<code>undefined</code>。它是在第三版引入为了区分空对象指针与未经初始化的变量。初始声明的未赋值或赋值<code>undefined</code>的变量是<code>undefined</code>;但与尚未定义的变量是不同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="comment">// 下面变量未声明</span></span><br><span class="line"><span class="comment">// let age;</span></span><br><span class="line">alert(message); <span class="comment">// “undefined”</span></span><br><span class="line">alert(age);     <span class="comment">// 产生错误</span></span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span> message)； <span class="comment">// “undefined”</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age)；     <span class="comment">// “undefined”</span></span><br></pre></td></tr></table></figure>

<p>然而，对未初始的变量执行<code>typeof</code>操作符会返回<code>undefined</code>值，对未声明的变量进行此操作结果也是<code>undefined</code>。</p>
</li>
<li><p><code>Null</code>类型也只有一个值，即<code>null</code>。从逻辑角度看，<code>null</code>表示一个空对象指针，这也正式为什么使用<code>typeof</code>操作符监测null值会返回”object”的原因。<strong>如果定义的变量用于保存对象，那么最好将该变量初始化为null而不是其他值。</strong>这样一来直接检查<code>null</code>值就可以知道相应的变量是否已保存了一个对象的引用。也就是，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存为<code>null</code>。这样做不仅体现<code>null</code>作为空对象指针的管理，而且有利于进一步区分<code>null</code>和<code>undefined</code>。</p>
</li>
<li><p><code>Boolean</code>类型有两个字面值:<code>true</code>和<code>false</code>。可以对任何数据类型的值调用<code>Boolean()</code>函数，而且总会返回一个<code>Boolean</code>值，该值被保存在<code>messageAsBoolean</code>变量中。</p>
</li>
<li><p><code>Number</code>类型使用了<code>IEEE754</code>格式来表示整数和浮点数。JS能够标识的最大数值保存在<code>Number.MIN_VALUE</code>中，值是<code>5e-324</code>；能够标识最大的值保存在<code>Number.MAX_VALUE</code>中，值是<code>1.7976931348623157e+308</code>。超出此范围的值会被转换为<code>Infinity</code>和<code>-Infinity</code>。可以使用<code>isFinite()</code>函数，函数在参数位于最小与最大数值之间时会返回<code>true</code>。</p>
</li>
<li><p><code>NaN</code>是一个特殊的数值，即非数值（Not a Number），这个数值用于标识一个本来要返回数值的操作数未返回数值的情况。<code>isNaN()</code>函数可以确定参数是否“不是数值”。<code>NaN</code>有两个特点：</p>
<ul>
<li>任何涉及<code>NaN</code>的操作都会返回<code>NaN</code>；</li>
<li><code>NaN</code>与任何值都不相等，包括<code>NaN</code>本身。</li>
</ul>
</li>
<li><p>数值转换，有3个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>。</p>
</li>
<li><p><code>String</code>类型用于表示由零或多个16位<code>Unicode</code>字符组成的字符序列，即字符串。<code>String</code>类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符或有其他用途的字符：<code>\n \t \b \r \f \\ \&#39; \&quot;</code>。</p>
</li>
<li><p>字符串是不可变的，字符串一旦创建，他们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p>
</li>
<li><p>转换为字符串的方法，几乎每个值都有<code>toString()</code>方法，包括：数值、布尔值、对象、字符串。但<code>null</code>和<code>undefined</code>值没有这个方法。默认情况下，该方法以十进制返回字符串，同事支持二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString());    <span class="comment">// "10"</span></span><br><span class="line">alert(num.toString(<span class="number">2</span>));   <span class="comment">// "1010"</span></span><br><span class="line">alert(num.toString(<span class="number">8</span>));   <span class="comment">// "12"</span></span><br><span class="line">alert(num.toString(<span class="number">10</span>));  <span class="comment">// "10"</span></span><br><span class="line">alert(num.toString(<span class="number">16</span>));  <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>

<p>另一个方法是<code>String()</code>，这个函数能转换任何类型的值为字符串。遵循的转换规则：</p>
<ul>
<li>如果值有<code>toString()</code>方法，则调用该方法并返回相应结果；</li>
<li>如果是<code>null</code>，则返回”null”；</li>
<li>如果是<code>undefined</code>，则返回”undefined”。</li>
</ul>
</li>
<li><p><code>Object</code>类型是一组数据和功能的集合。它是所有它的实例的基础，即<code>Object</code>类型所具有的任何属性和方法也同样存在于更具体的对象中。每个实例都具有下列的属性和方法：</p>
<ul>
<li><code>constructor</code>：构造函数，保存着创建当前对象的函数；</li>
<li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在；</li>
<li><code>isPrototypeOf(object)</code>：检查传入的对象是否是传入对象的原型；</li>
<li><code>propertyIsEnumerable(propertyName)</code>：检查给定的属性是否能够用<code>for-in</code>语句来枚举。</li>
<li><code>toLocalString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应；</li>
<li><code>toString()</code>：返回对象的字符串表示；</li>
<li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示。通常与<code>toString()</code>方法的返回值相同。</li>
</ul>
</li>
<li><p>操作符用于操作数值：包括算数操作符、位操作符、关系操作符、相等操作符。</p>
<ul>
<li><p>一元操作符：递增<code>++</code>、递减<code>—</code>、加<code>+</code>、减<code>-</code>；</p>
</li>
<li><p>位操作符：JS中的所有数值都是以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值，而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于有符整数，第32位表示符号，0 表示整数，1表示负数。负数使用的是二进制补码。</p>
<ol>
<li>按位非<code>~</code>：返回数值的反码；</li>
<li>按位与<code>&amp;</code>：对应位都是1返回1，任何一位是0，结果返回0；</li>
<li>按位或<code>|</code>：有一个位是1就返回1，只有两个位是0才返回0；</li>
<li>按未异或<code>^</code>：只有一个1时才返回1，两个位都是1或都是0，返回0；</li>
<li>左移<code>&lt;&lt;</code>：将数值的所有位向左移动指定的位数；</li>
<li>有符右移<code>&gt;&gt;</code>：将数值向右移动，但保留符号位；在右移过程中会出现空位，空位在原数值的左侧、符号位右侧，此时会用<strong>符号位的值</strong>来填充所有空位；</li>
<li>无符号右移<code>&gt;&gt;&gt;</code>：将数值的所有32位向右移动；对正数来说，结果与有符右移相同。对于负数，无符号右移以0来填充空位，而不是像有符号右移以符号位的值来填充空位。无符右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制码补码形式存在，因此就会导致无符号右移后的结果非常之大。如：<code>-64</code>的二进制码为<code>11111111111111111111111111000000</code>，无符右移之后会把二进制码当成正数的二进制码，换算成十进制就是<code>4294967232</code>，右移5位之后就成了<code>00000111111111111111111111111110</code>即十进制<code>134217726</code>。</li>
</ol>
</li>
<li><p>布尔操作符：布尔操作符一共有3个：与<code>&amp;&amp;</code>、或<code>||</code>、非<code>!</code>；</p>
</li>
<li><p>乘性操作符：乘法、除法、求模；</p>
</li>
<li><p>加性操作符：加法、减法；</p>
</li>
<li><p>关系操作符：小于、大于、小于等于、大于等于；</p>
</li>
<li><p>相等操作符：相等<code>==</code>和不相等<code>!=</code>，先转换再比较；全等<code>===</code>和不全等<code>!==</code>，仅比较不转换，推荐使用。</p>
<ul>
<li>相等和不相等：先强制转型，再比较相等性</li>
<li>全等和不全等：两个操作数未经转换就相等的情况下返回<code>true</code></li>
</ul>
</li>
<li><p>条件操作符：<code>variable = boolean_expression ? true_value : false_value;</code></p>
</li>
<li><p>赋值操作符：把右侧的值赋值给左侧的变量。下面是简化的复合赋值操作符，这些操作符的主要目的是简化赋值操作，不会带来任何性能的提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">= *= <span class="regexp">/= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逗号操作符：可以在一条语句中执行多个操作，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>label</code>语句，使用label语句可以再代码中添加标签，以便将来使用：<code>label: statement</code>。例子：定义start标签，可以再将来由break或continue语句引用。加标签的语句一般都要与for语句等循环语句进行配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数：JS函数的参数不介意传进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个或三个，解析器都可以解析。因为JS中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过<code>arguments</code>对象来访问这个参数数组，从而获取传递函数的每个参数。没有传递值的命令参数将自动被赋予<code>undefined</code>值，这就跟定义了变量但又没有初始化一样。</p>
</li>
<li><p>函数没有重载：在其他语言中，可以为一个函数编写两个定义，只要两个定义的签名（接受的参数的类型和数量）不同即可。JS函数没有签名，因为参数是由包含零或多个值的数组来表示的。如果函数名字相同，之后定义的函数会覆盖先定义的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li><p>定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是对不同类型值进行操作是不一样的，对于引用类型我们可以为其添加属性和方法，也可以改变和删除其属性和方法。但是我们不能给基本类型添加属性或方法，尽管这样做不会导致错误。</p>
</li>
<li><p>复制变量值：如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。</p>
</li>
<li><p>传递参数：JS所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。在向参数传递基本类型值的值时，被传递的值会被复制给一个局部变量。在向参数传递引用类型时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p>
</li>
<li><p>检测类型：<code>typeof</code>在检测基本数据类型时很有用，但在检测引用类型的值时，它的用处不大。通常，我们并不想知道某个值是对象，而是想知道它是什么类型的对象。JS提供了<code>instanceof</code>操作符，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>

<p>如果变量是给定引用类型的实例，那么<code>instanceof</code>操作符就会返回<code>true</code>。根据规定，所有引用类型的值都是<code>Object</code>的实例。因此在检测一个引用类型值和<code>Object</code>构造函数时，<code>instanceof</code>操作符始终会返回<code>true</code>。检测基本类型的值，会返回<code>false</code>，因为基本类型不是对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量person是Object吗</span></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); </span><br><span class="line"><span class="comment">// 变量colors是Array吗</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); </span><br><span class="line">alert(patterninstanceofRegExp);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ol>
<li><p>引用类型的值（对象）是引用类型的一个实例。在JavaScript中引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。</p>
</li>
<li><p>创建Object实例的方式有两种。一种是使用<code>new Object()</code>；另一种是使用对象字面量表示法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在使用对象字面量语法时，属性名也可以使用字符串，但这里的数值属性名会自动转换为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">         <span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line">         <span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line">         <span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>访问对象属性时可以使用点表示法或方括号表示法。方括号表示法的有点事可以通过变量来访问属性。</p>
</li>
<li><p>JS数组的每一项可以用来保存任何类型的数据。数组的大小可以动态调整，即可以随着数据的添加自动增长以容纳新增数据。<code>Array.isArray()</code>可以用来检测数据是不是数组。</p>
</li>
<li><p>所有对象都具有<code>toLocalString()</code>、<code>toString()</code>、<code>valueOf()</code>方法。<code>toString()</code>方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</p>
</li>
<li><p>Array的方法:</p>
<ul>
<li><code>push()</code>：在数组末端添加任意个项，并返回新数组的长度</li>
<li><code>pop()</code>：移除数组中的最后一项，并返回此值</li>
<li><code>shift()</code>：移除数组中的第一个项，并返回此值</li>
<li><code>unshift()</code>：在数组前端添加任意个项，并返回新数组的长度</li>
<li><code>reverse()</code>：数组倒序排列，返回排序后的数组</li>
<li><code>sort()</code>：按升序排列数组项；或者接收一个函数，进行定制排序设计；返回排序后的数组</li>
<li><code>concat()</code>：合并两个或多个数组，并返回新数组</li>
<li><code>slice()</code>：</li>
<li><code>splice</code>：主要用途是向数组中部插入项，有三种使用方法：<ol>
<li>删除：可以删除任意数量的项，只需指定2个参数，要删除的第一项的位置和要删除的项数。如：splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，主需要提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果插入多个项，可以再传入第四、第五，以至任意多个项。如：splice(2,0,”red”, “green”)会从当前数组的位置2开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需要指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。如：splice(2,1,”red”,”green”)会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”。</li>
</ol>
</li>
<li><code>indexOf()</code>和<code>lastIndexOf</code>：这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。分别是：从数组的开头开始向后查找；从数组末尾开始向前查找；都返回查找的项在数组中的位置，或者在没有找到的情况下返回-1。</li>
<li>迭代方法<code>every()</code>：对数组中每一项运行给定函数，如果该函数对每一项都返回<code>true</code>,则返回<code>true</code></li>
<li><code>filter</code>：对数组中每一项运行给定函数，返回该函数会返回<code>true</code>的项组成的数组。</li>
<li><code>forEach()</code>：对数组中每一项运行给定函数。无返回值。</li>
<li><code>map()</code>：对数组中每一项运行给定函数，返回每次调用的结构组成的数组。</li>
<li><code>some()</code>：对数组中每一项运行给定函数，如果该函数对任一项返回<code>true</code>，则返回<code>true</code>。</li>
<li>归并方法<code>reduce()</code>和<code>reduceRight()</code>：两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，<code>reduce()</code>方法从数组的第一项开始，逐个遍历到最后。而<code>reduceRigth()</code>从数组追后一项开始，向前遍历到第一项。都接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。函数接受四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。</li>
</ul>
</li>
<li><p>JS中的<code>Date</code>类型使用自<code>UTC</code>时间。<code>Date</code>类型重写了<code>toLocalString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。<code>valueOf（）</code>方法直接返回日期的毫秒表示。</p>
</li>
<li><p>常用的日期方法：</p>
<ul>
<li><code>getTime()</code>：返回日期的毫秒数</li>
<li><code>getFullYear()</code>：取得4位数的年份</li>
<li><code>getMonth()</code>：返回日期中的月份，从0开始，0表示1月</li>
<li><code>getDate()</code>：返回日期月份中的天数（1到31）</li>
<li><code>getDay()</code>：返回星期中的星期几，从0开始</li>
<li><code>getHours()</code>：返回日期中的小时数</li>
<li><code>getMinutes()</code>：返回日期中的分钟数(0到59)</li>
<li><code>getSeconds()</code>：返回日期中的秒数，超过59会增加分钟数</li>
</ul>
</li>
<li><p>RegExp类型</p>
</li>
<li><p>在JS中函数实际上是对象。<code>Function</code>函数的方式是使用构造函数，可以接收任意数量的参数，但最后一个参数始终都被看成函数体，而前面的参数则枚举出了新函数的参数。下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</span><br></pre></td></tr></table></figure>

<p>从技术角度讲，这是一个函数表达式。但是，不推荐使用这种方法定义函数，因为这种语法导致解析两次代码（第一次是解析床柜JS代码，第二次是解析传入构造函数中的字符串），产品那个人影响性能。但是这种语法可以让人很直观地理解“函数是对象，函数名是指针”的概念。</p>
</li>
<li><p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同，即一个函数可能有多个名字。使用不带括号的函数名是访问函数指针，而非调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));        <span class="comment">//20</span></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>此时，<code>anotherSum</code>和<code>sum</code>就指向了同一个函数，调用<code>snotherSum()</code>也可以被调用并返回结果。</p>
</li>
<li><p>深入理解函数没有重载：将函数名想象为指针，上面提到的函数名相同后面的会覆盖前面的。而利用指针概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="number">6</span> <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>

<p>重写代码后，创建的第二个函数实际上覆盖了引用第一个函数的变量<code>addSomeNumber</code>。</p>
</li>
<li><p>函数声明与函数表达式：解析器在执行环境中加载数据时，对函数声明，解析器会率先读取，并使其在执行任何代码之前可用；置于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</p>
</li>
<li><p>因为JS的函数名本身就是变量，所以函数也可以作为值来使用。不仅可以当做参数，也可以当做值来返回。</p>
</li>
<li><p>函数内部有两个特殊的对象：<code>arguments</code>和<code>this</code>。<code>arguments.caller</code>该属性是一个指针，指向保存着调用当前函数的函数的引用；<code>arguments.callee</code>也是一个指针，指向拥有这个<code>arguments</code>对象的函数。</p>
</li>
<li><p>每个函数都包含两个属性：<code>length</code>和<code>prototype</code>。<code>length</code>表示函数接收的命名参数的个数。<code>prototype</code>属性是不可枚举的。</p>
</li>
<li><p>每个函数包含三个非继承而来的方法：<code>apply()</code>和<code>call()</code>。作用：在特定的作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值。<code>bind()</code>：会创建一个函数的实例，其<code>this</code>值会被绑定到传给<code>bind()</code>函数的值。</p>
</li>
<li><p>为了便于操作基本类型值，JS还提供了3个特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<ol>
<li>创建String类型的一个实例；</li>
<li>在实例上调用指定的方法；</li>
<li>销毁这个实例</li>
</ol>
<p>可以把这三个步骤想象成执行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用类型和基本包装类型的主要区别是对象的生存期。使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用于之前都一直保存在内存中。自动创建的基本包装类型对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color);   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>第二行创建的String对象在执行第三行代码时已经被销毁了；第三行又创建了自己的String对象，而该对象没有<code>color</code>属性。</p>
</li>
<li><p><code>Number</code>是与数字值对应的引用类型。Number类型重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法，重写后<code>valueOf()</code>返回对象表示的基本类型的数值，另外两个函数则返回字符串形式的数值。<code>toString()</code>将数值转为字符串，默认是10进制；<code>toFixed()</code>方法会按照指定的小数位返回数值的字符串表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1.toFixed(<span class="number">2</span>)); <span class="comment">// "10.00"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// "10.01"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String</code>类型是字符串的对象包装类型。这个类型中有很多方法帮助字符串进行解析和操作：</p>
<ul>
<li><p>字符方法<code>charAt()</code>和<code>charCodeAt()</code>：接收一个基于0的字符位置。第一个函数返回给定位置的那个字符。第二个函数返回给定位置的那个字符的字符编码。</p>
</li>
<li><p>字符串操作方法：<code>concat()</code>:将一个或多个字符串拼接起来。可以用加号操作符或字符串模板代替。<code>slice</code>、 <code>substr()</code>和<code>substring()</code>这三个方法都会返回被操作字符串的一个子字符串，而且也接收一个或两个参数。第一个参数指定字符串的开始位置，第二个参数表示子字符串到哪里结束。具体来说，<code>slice()</code>和<code>substring()</code>的第二个参数指定的是子字符串最后一个字符后面的位置。而<code>substr()</code>的第二个参数指定的则是返回的字符个数。这些函数都是不会修改字符串本身的值，只是返回一个基本类型的字符串值。在给这些方法传递负数的情况下，<code>slice()</code>会将传入的负值与字符串的长度相加，<code>substr()</code>方法将负的第一个参数加上字符串长度，而将负的第二个参数转换为0，<code>substring()</code>会把所有的负数参数都转为0。</p>
</li>
<li><p>字符串位置方法<code>indexOf()</code>和<code>lastIndexOf()</code>：从一个字符串中搜索给定的子字符串，然后返会子字符串的位置，没找到则返回-1。区别是：前者是从字符串开头向后搜索子字符串，而后者是从字符串的末尾向前搜索子字符串。都有第二个参数，表示从字符串的哪个位置开始搜索。</p>
</li>
<li><p><code>trim()</code>：创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果。</p>
</li>
<li><p>字符串大小写转换方法：<code>toLowercase()</code>、<code>toUpperCase()</code>。</p>
</li>
<li><p>字符串模糊匹配方法<code>match()</code>、<code>search()</code>、<code>replace()</code></p>
</li>
<li><p><code>localeCompare()</code>：比较两个字符串，字符串比参数字符串在字母表之前返回-1,相同返回0，之后返回1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>; alert(stringValue.localeCompare(<span class="string">"brick"</span>)); <span class="comment">//1 </span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"yellow"</span>)); <span class="comment">//0 </span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"zoo"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fromCharCode()</code>：接收一或多个字符编码，然后将它们转换成一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>); <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>内置对象的定义是：由JS实现提供的、不依赖于宿主环境的对象，这些对象在JS程序执行之前就已经存在了。即在使用时开发人员不必显示地实例化内置对象，因为它们已经实例化了。内置对象：<code>Object</code>、<code>Array</code>、<code>String</code>。JS还定义了两个单体内置对象<code>Global</code>、<code>Math</code>。</p>
</li>
<li><p><code>Global</code>对象是一个很特别的对象，不管从什么角度看，这个对象都是不存在的。JS中的<code>Global</code>对象：不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是<code>Global</code>对象的属性。诸如<code>isNan()</code>、<code>isFinite()</code>、<code>parseInt()</code>以及<code>parseFloat()</code>实际上全都是<code>Global</code>对象的方法。</p>
</li>
<li><p><code>Global</code>对象的其他方法：<code>encodeURI()</code>、<code>encodeURIComopnent()</code>可以对URI（Uniform Resource Identifiers，通用资源标识符）进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。</p>
<ul>
<li><p><code>encodeURI()</code>主要用于整个URI，<code>encodeURIComopnent()</code>用于对URI的某一段进行编码。区别在于<code>encodeURI()</code>不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码。第二个使用更多，因为实践中更常见的是对查询字符串参数而不是基础URI进行编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>decodeURI()</code>、<code>decodeURIComponent()</code>，第一个只对<code>encodeURI()</code>替换的字符进行编码。第二个可以解码任何特殊字符的编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span>;</span><br><span class="line">    <span class="comment">//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));</span><br><span class="line"><span class="comment">//http://www.wrox.com/illegal value.htm#start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>eval()</code>：将传入的参数当做实际的JS语句来解析，然后把执行结果插入到原位置。</p>
</li>
<li><p><code>Global</code>对象的属性：</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E5%9F%BA%E7%A1%8001.png" alt=""></p>
</li>
</ul>
</li>
<li><p>Math对象的属性：大都是数学计算中可能用到的一些特殊值。</p>
</li>
<li><p>Math对象的方法：</p>
<ul>
<li><p><code>min()</code>、<code>max()</code>确定一组数之中的最小值和最大值。</p>
</li>
<li><p>舍入方法：<code>ceil()</code>：向上舍入；<code>floor()</code>向下舍入；<code>round()</code>：四舍五入</p>
</li>
<li><p><code>random()</code>：返回大于等于0小于1的一个随机数</p>
</li>
<li><p>其他方法：</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E5%9F%BA%E7%A1%8002.png" alt=""></p>
</li>
</ul>
</li>
</ol>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><ol>
<li><p><code>ECMA-262</code>把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数，即对象是一组没有特定顺序的值。</p>
</li>
<li><p>数据属性和访问器属性：数据属性包含一个数据值的位置；访问器属性包含一对<code>getter()</code>和<code>setter()</code>函数，不过这两个函数都不是必须的。</p>
</li>
<li><p>创建对象的几种模式：</p>
</li>
<li><p>工厂模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>函数<code>createPerson()</code>能根据接受的参数来构建一个包含所有必要信息的<code>Person</code>对象。此模式虽然解决了创建多个相似对象的问题，但没有解决对象的识别问题即怎样知道一个对象的类型。</p>
</li>
<li><p>构造函数模式：JS的构造函数可用来创建特定类型的对象，如Object和Array这样的原生构造函数。也可以创建自定义构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>与工厂模式不同的是：没有显示地创建对象；直接将属性和方法赋给了<code>this</code>对象；没有<code>return</code>语句；函数名<code>Person</code>使用的是大写字母P，主要为了区别JS中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p>
<p>这种方式调用构造函数会经过以下4个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象，因此this就指向了这个新对象；</li>
<li>执行构造函数中的代码，为这个对象添加属性；</li>
<li>返回新对象。</li>
</ol>
<p>这两个对象都有<code>constructor</code>属性，该属性指向<code>Person</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>构造函数和普通函数没区别，通过new操作符调用就可以作为构造函数，不通过new调用，就是普通函数。</p>
<p>使用构造函数的主要问题是每个方法都要在每个实例上重新创建一遍。前面的<code>person1</code>、<code>person2</code>都有一个名为<code>sayName()</code>的方法，但这两个方法不是同一个<code>Function</code>的实例。因为JS中函数是对象，所以每定义一个函数，也就实例化了一个对象。从逻辑上讲，此时的构造函数也可以这样定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>);                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看，更容易看明白，每个<code>Person</code>实例都包含一个不同的<code>Function</code>实例。也就是以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建<code>Function</code>新实例的机制仍然相同。因此不同实例上的同名函数是不相等的。创建两个完成同样任务的<code>Function</code>实例没有必要，且有<code>this</code>对象在，不用再代码执行前就把函数绑定到特定对象上面。可以把函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>这样确实解决了这个问题，但是新的问题出现了。在全局作用域中定义的函数只能被某个对象调用，而且如果对象需要定义许多方法，那么就要定义很多个全局函数，那么我们自定义的引用类型就没有封装性可言了。</p>
</li>
<li><p>原型模式：创建的每个函数都有一个<code>prototype</code>属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>按照字面意思理解，<code>prototype</code>就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>与构造函数模式不同的是，新对象的这些属性和方法由所有实例共享。<code>person1</code>和<code>person2</code>访问的都是同一组属性和同一个<code>sayName()</code>函数。</p>
</li>
<li><p>组合使用构造函数模式和原型模式：这是最常用的一种方式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。结果，每个实例有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种模式还支持向构造函数中传递参数，可谓集两者之长。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;  </span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span> : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">// false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性<code>constructor</code>和方法<code>sayName()</code>则是在原型中定义的。而修改了 <code>personl.friends</code> (向其中添加一个新字符串），并不会影响到<code>person2.friends</code>，因为它们分别引用了不同的数组。 这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
</li>
<li><p>动态原型模式：把所有信息封装在构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。也就是说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	<span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>

<p>仅在<code>sayName()</code>不存在的情况下，才会添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，完成初始化后不需要再做什么改修了。请记住，不能使用对象字面量重写原型，重写之后会切断现有实例与新原型之间的联系。</p>
</li>
<li><p>寄生构造模式：基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新对象的创建；表面上看，很像是典型的狗在函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="keyword">return</span> o; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>这个模式可以在特殊的情况下用来为对象创建构造函数。如创建一个具有额外方法的特殊数组。由于不能直接修改构造函数，可以使用这个模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 创建数组    </span></span><br><span class="line">	<span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加值 </span></span><br><span class="line">	values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加方法</span></span><br><span class="line">	values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">	    &#125;;</span><br><span class="line">	<span class="comment">// 返回数组</span></span><br><span class="line">	<span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// "red|blue|green"</span></span><br></pre></td></tr></table></figure>

<p>有一点需要说明：首先，返回的对象与构造函数或者构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖<code>instanceof</code>操作符来确定对象类型。由于上述存在的问题，建议使用其他模式，不要用这种模式。靠</p>
</li>
<li><p>稳妥构造函数模式：首先要提到稳妥对象，指的是没有公共属性，而且其方法也不引用<code>this</code>的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用<code>this</code>和<code>new</code>），或者放置数据被其他应用程序改动时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 在这里定义私有变量和函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="keyword">return</span> o; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>这样，变量<code>friend</code>中保存的是一个稳妥对象，而除了调用<code>sayName ()</code>方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传 人到构造函数中的原始数据。</p>
</li>
</ol>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><ol>
<li><p>定义函数的方式有两种：一种是函数声明，另一种是函数表达式。关于函数声明，一个重要的特征就是<strong>函数声明提升</strong>，即在执行代码之前会先读取函数声明。关于函数表达式，形式好像常规的变量赋值语句，即创建一个函数并将它赋值给变量，这种情况下创建的函数叫<strong>匿名函数</strong>，又叫拉姆达函数。</p>
<p> 理解函数提升的关键，就是理解函数声明与函数表达式之间的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误 函数声明提升</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Yo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> sayHi;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Yo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归函数：在一个函数通过名字调用自身的情况下构成递归函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个经典的递归阶乘函数，虽然表面看着没有问题，但是下面代码可能出错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>以上代码先把<code>factorial()</code>函数保存到<code>anotherFactorial</code>中，再将<code>factorial</code>设置为<code>null</code>，结果指向原始函数的引用只剩下一个。但在接下来的调用中，函数内部必须执行<code>factorial()</code>，而<code>factorial</code>已经不再是函数，所以就会导致出错。</p>
<p>这时<code>arguments.callee</code>可以解决这个问题，它是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证无论怎样调用函数都不会出现问题，因此使用<code>arguments.callee</code>代替匿名函数更为保险。</p>
<p>但是在严格模式下，访问这个属性会导致错误。不过，可以使用匿名函数达到相同的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码创建一个名为<code>f()</code>的函数命令表达式，然后将它赋值给<code>factorial</code>，这样几遍把函数赋值给另一个变量，函数的名字仍然有效，所以递归调用照样能正确完成。这种严格模式和非严格模式下都行得通。</p>
</li>
<li><p>闭包函数：闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>value1</code>和<code>value2</code>两行代码时内部函数（一个匿名函数）中的代码，这梁行代码访问了外部函数中的变量<code>propertyName</code>。即使这个内部函数被放回了，而且是在其他地方被调用了，但它仍然可以访问变量<code>propertyName</code>。之所以还能访问这个变量，是因为内部函数的作用域链中包含<code>createComparisonFunction()</code>的作用域。要搞清楚其中的<a href="./JS的执行环境及作用域.md">细节</a>，必须从理解函数被调用的时候都会发生什么入手。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/Network/%E7%A7%BB%E5%8A%A8OneNET%E5%B9%B3%E5%8F%B0%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/Network/%E7%A7%BB%E5%8A%A8OneNET%E5%B9%B3%E5%8F%B0%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/" class="post-title-link" itemprop="url">移动OneNET平台初步了解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-23 10:23:10" itemprop="dateCreated datePublished" datetime="2018-12-23T10:23:10+08:00">2018-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-16 10:37:19" itemprop="dateModified" datetime="2020-05-16T10:37:19+08:00">2020-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="移动OneNET平台初步了解"><a href="#移动OneNET平台初步了解" class="headerlink" title="移动OneNET平台初步了解"></a>移动OneNET平台初步了解</h1><p>之前公司有支持过电信的NB平台，目前着手对接移动平台，现在对此平台做初步了解，在此简单记录。</p>
<p>具体内容请参见官方开发文档：<a href="https://open.iot.10086.cn/doc/" target="_blank" rel="noopener">https://open.iot.10086.cn/doc/</a></p>
<h2 id="一、平台介绍"><a href="#一、平台介绍" class="headerlink" title="一、平台介绍"></a>一、平台介绍</h2><blockquote>
<p>OneNET定位为PaaS服务，即在物联网应用和真实设备之间搭建高效、稳定、安全的应用平台。</p>
</blockquote>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>平台的主要功能主要为：</p>
<ul>
<li>设备接入：支持多种行业和主流标准协议的设备接入</li>
<li>设备管理：支持设备的生命周期（注册/更新/查询/删除）、在线状态、数据存储、调试及日志</li>
<li>数据及访问安全</li>
<li>API支持：通过简单调用快速实现应用</li>
<li>应用集成工具：提供消息队列MQ和HTTP推送服务</li>
<li>简易应用孵化工具</li>
</ul>
<p>详情参见：<a href="https://open.iot.10086.cn/doc/book/introduce/introduce.html" target="_blank" rel="noopener">https://open.iot.10086.cn/doc/book/introduce/introduce.html</a></p>
<h3 id="平台架构"><a href="#平台架构" class="headerlink" title="平台架构"></a>平台架构</h3><p><img src="https://open.iot.10086.cn/doc/images/%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84new1.png" alt=""></p>
<p><strong>设备接入</strong></p>
<p>平台提供多种协议完成设备接入，OneNET建议根据不同的场景选择合适的协议：</p>
<ul>
<li><code>LwM2M（CoAP）</code>：低能耗广覆盖场景</li>
<li><code>MQTT</code>：需要与设备实时通信的场景</li>
<li><code>Modbus</code>：工业modbus通信场景，建议DTU+modbus</li>
<li><code>HTTP/HTTPS</code>：设备单纯上报数据的场景</li>
<li><code>TCP</code>：用户需要自定义协议接入的场景，建议采用TCP+脚本的方式接入</li>
</ul>
<p><strong>设备管理</strong></p>
<p>OneNET平台针对不同的使用场景，提供关于设备的包括生命周期管理、在线状态监测、在线调试、数据管理等功能在内的丰富的设备管理功能。</p>
<p><strong>API</strong></p>
<p>提供基于HTTP/HTTPS的API接口，用户可以使用API进行设备管理，数据查询，设备命令交互等操作，在API的基础上，根据自己的个性化需求指定搭建上层应用。</p>
<p><strong>HTTP推送</strong></p>
<p>针对某些实时性要求较高的场景提供数据推送功能。<strong>可以过滤掉设备端频繁的周期性上报数据，将用户关心的实时性较高的数据，通过HTTP/HTTPS的方式推送到用户的应用服务器上。</strong></p>
<p><strong>消息队列MQ</strong></p>
<p>为满足应用层快速可靠地获取设备消息而推出的消息中间件服务。用户可自定义消息生产者和消费者。</p>
<p><strong>安全认证</strong></p>
<p>详情参见：<a href="https://open.iot.10086.cn/doc/book/introduce/architecture.html" target="_blank" rel="noopener">https://open.iot.10086.cn/doc/book/introduce/architecture.html</a></p>
<h3 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h3><p><img src="https://open.iot.10086.cn/doc/images/%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p>产品相当于项目</p>
<p>详情参见：<a href="https://open.iot.10086.cn/doc/book/introduce/resource-model.html" target="_blank" rel="noopener">https://open.iot.10086.cn/doc/book/introduce/resource-model.html</a></p>
<h2 id="二、快速开始"><a href="#二、快速开始" class="headerlink" title="二、快速开始"></a>二、快速开始</h2><h3 id="注册登录"><a href="#注册登录" class="headerlink" title="注册登录"></a>注册登录</h3><p>用户可自行进行注册，注册的用户可以进行认证，认证分为企业认证和个人认证。</p>
<p>认证与产品之间的关系：</p>
<table>
<thead>
<tr>
<th>认证方式</th>
<th>允许创建产品总数</th>
<th>每个产品接入设备总数</th>
</tr>
</thead>
<tbody><tr>
<td>未实名认证</td>
<td>3</td>
<td>10</td>
</tr>
<tr>
<td>完成个人认证</td>
<td>10</td>
<td>1000</td>
</tr>
<tr>
<td>完成企业认证</td>
<td>暂不限制</td>
<td>暂不限制</td>
</tr>
</tbody></table>
<p>详情参见：<a href="https://open.iot.10086.cn/doc/book/easy-manual/login.html" target="_blank" rel="noopener">https://open.iot.10086.cn/doc/book/easy-manual/login.html</a></p>
<h3 id="创建产品（项目）和设备"><a href="#创建产品（项目）和设备" class="headerlink" title="创建产品（项目）和设备"></a>创建产品（项目）和设备</h3><p>详情参见：<a href="https://open.iot.10086.cn/doc/book/easy-manual/product&amp;device/product-create.html" target="_blank" rel="noopener">https://open.iot.10086.cn/doc/book/easy-manual/product&amp;device/product-create.html</a></p>
<h3 id="数据流与数据点"><a href="#数据流与数据点" class="headerlink" title="数据流与数据点"></a>数据流与数据点</h3><p>平台通过数据流与数据点来组织设备上行数据，如图：</p>
<p><img src="https://open.iot.10086.cn/doc/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%82%B91.png" alt=""></p>
<p>设备上传并存储数据时，必须以<code>key-value</code>的格式上传数据，其中<code>key</code>即为数据流(stream)名称，<code>value</code>为实际存储的数据点(point)，<code>value</code>格式可以为<code>int</code>、<code>float</code>、<code>string</code>、<code>json</code>等多种自定义格式。</p>
<p>在实际应用中，数据流可以被用于分类描述设备的某一类属性数据，例如温度，湿度，坐标等信息，用户可以自定义数据流的数据范围，将<strong>相关性较高的数据</strong>归类为一个数据流。</p>
<h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><p>可以在OneNET平台上快速实现设备的数据流可视化。</p>
<p>实现方式是通过平台提供的控件进行具体的实现，控件分为：</p>
<ul>
<li>基础控件：只能可视化设备的数据流值，不能对设备下发命令、修改数据流值。</li>
<li>控制控件：除了能可视化设备的数据流值外，还可以下发命令给设备。</li>
</ul>
<h3 id="消息队列MQ"><a href="#消息队列MQ" class="headerlink" title="消息队列MQ"></a>消息队列MQ</h3><p>目前为公测阶段。</p>
<p>消息队列MQ定位为OneNET设备接入服务使用的，用于实现应用层快速、即时、可靠地获取设备消息的<strong>物联网服务组件</strong>，服务模型如下：</p>
<p><img src="https://open.iot.10086.cn/doc/images/mq/MQ%E6%A6%82%E8%BF%B0new.png" alt=""></p>
<h3 id="HTTP推送"><a href="#HTTP推送" class="headerlink" title="HTTP推送"></a>HTTP推送</h3><p>平台提供HTTP推送功能，可以主动将设备相关数据与消息以HTTP/HTTPS POST请求的方式，发送给应用服务器。</p>
<h2 id="设备开发"><a href="#设备开发" class="headerlink" title="设备开发"></a>设备开发</h2><h2 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/Network/%E5%86%99%E7%BB%99%E9%9D%9E%E4%B8%93%E4%B8%9A%E4%BA%BA%E5%A3%AB%E7%9C%8B%E7%9A%84Shadowsocks%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/Network/%E5%86%99%E7%BB%99%E9%9D%9E%E4%B8%93%E4%B8%9A%E4%BA%BA%E5%A3%AB%E7%9C%8B%E7%9A%84Shadowsocks%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">写给非专业人士看的 Shadowsocks 简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-19 11:23:10" itemprop="dateCreated datePublished" datetime="2018-12-19T11:23:10+08:00">2018-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-27 17:56:53" itemprop="dateModified" datetime="2019-12-27T17:56:53+08:00">2019-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写给非专业人士看的-Shadowsocks-简介"><a href="#写给非专业人士看的-Shadowsocks-简介" class="headerlink" title="写给非专业人士看的 Shadowsocks 简介"></a>写给非专业人士看的 Shadowsocks 简介</h1><blockquote>
<p>转自：<a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="noopener">http://vc2tea.com/whats-shadowsocks/</a></p>
</blockquote>
<h2 id="long-long-ago…"><a href="#long-long-ago…" class="headerlink" title="long long ago…"></a>long long ago…</h2><p>在很久很久以前，我们访问各种网站都是简单而直接的，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/NetWork/Shadowsocks%E7%AE%80%E4%BB%8B01.png" alt=""></p>
<h2 id="when-GFW-comes"><a href="#when-GFW-comes" class="headerlink" title="when GFW comes"></a>when GFW comes</h2><p>然后有一天，<a href="http://zh.wikipedia.org/wiki/%E9%87%91%E7%9B%BE%E5%B7%A5%E7%A8%8B" target="_blank" rel="noopener">GFW</a> 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 <code>Connection Reset</code> 这样的响应内容，而无法接收到正常的内容 。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/NetWork/Shadowsocks%E7%AE%80%E4%BB%8B02.png" alt=""></p>
<h2 id="ssh-tunnel"><a href="#ssh-tunnel" class="headerlink" title="ssh tunnel"></a>ssh tunnel</h2><p>聪明的人们想到了利用境外服务器代理的方法来绕过 GFW 的过滤，其中包含了各种HTTP代理服务、Socks服务、VPN服务… </p>
<p>其中以 ssh tunnel 的方法比较有代表性：</p>
<p>1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道；</p>
<p>2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求； </p>
<p>4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户；</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/NetWork/Shadowsocks%E7%AE%80%E4%BB%8B03.png" alt=""></p>
<p>由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题。</p>
<h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>于是 <a href="https://github.com/clowwindy/shadowsocks" target="_blank" rel="noopener">clowwindy</a> 同学分享并开源了他的<a href="http://www.v2ex.com/t/32777" target="_blank" rel="noopener">解决方案</a></p>
<p>简单理解的话，shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似。</p>
<p>1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 。</p>
<p>2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密。</p>
<p> 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/NetWork/Shadowsocks%E7%AE%80%E4%BB%8B04.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/Other/Debug%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/Other/Debug%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Debug模式操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-19 11:23:10" itemprop="dateCreated datePublished" datetime="2018-12-19T11:23:10+08:00">2018-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-27 17:56:53" itemprop="dateModified" datetime="2019-12-27T17:56:53+08:00">2019-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Debug模式操作"><a href="#Debug模式操作" class="headerlink" title="Debug模式操作"></a>Debug模式操作</h1><p>之前写PHP只要在页面上调试即可，几乎没用过<code>debug</code>调试模式，今天学习js用到，记录下自己所用到的。</p>
<ol>
<li><p><code>step into/step out/step over</code>的区别:</p>
<ul>
<li>step into：单步执行，遇到子函数就进入并且继续单步执行（==进入子函数==）；</li>
<li>step over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（==越过子函数，但子函数会执行==）。</li>
<li>step out：当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数（==跳出子函数==）。</li>
</ul>
<p>​</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/Other/MarkDown%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/Other/MarkDown%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">MarkDown教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-19 11:23:10" itemprop="dateCreated datePublished" datetime="2018-12-19T11:23:10+08:00">2018-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-15 18:22:59" itemprop="dateModified" datetime="2020-05-15T18:22:59+08:00">2020-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Guide"><a href="#Guide" class="headerlink" title="Guide"></a>Guide</h2><p>这是一篇讲解如何正确使用 <strong>Markdown</strong> 的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。</p>
<blockquote>
<p>引用文本：Markdown is a text formatting syntax inspired</p>
</blockquote>
<h2 id="语法指导"><a href="#语法指导" class="headerlink" title="语法指导"></a>语法指导</h2><h3 id="普通内容"><a href="#普通内容" class="headerlink" title="普通内容"></a>普通内容</h3><p>这段内容展示了在内容里面一些排版格式，比如：</p>
<ul>
<li><strong>加粗</strong> - <code>**加粗**</code></li>
<li><em>倾斜</em> - <code>*倾斜*</code></li>
<li><del>删除线</del> - <code>~~删除线~~</code></li>
<li><code>Code 标记</code> - <code>Code 标记</code></li>
<li><a href="http://github.com" target="_blank" rel="noopener">超级链接</a> - <code>[超级链接](http://github.com)</code></li>
<li><a href="mailto:username@gmail.com">username@gmail.com</a> - <code>[username@gmail.com](mailto:username@gmail.com)</code></li>
</ul>
<h3 id="提及用户"><a href="#提及用户" class="headerlink" title="提及用户"></a>提及用户</h3><p>@Vanessa … 通过 @ 可以在发帖和回帖里面提及用户，被提及的用户将会收到系统通知，以便让他来关注这个帖子或回帖。</p>
<blockquote>
<p>NOTE:</p>
<ol>
<li>@用户名之后需要有一个空格</li>
<li>新手没有艾特的功能权限</li>
</ol>
</blockquote>
<h3 id="表情符号-Emoji"><a href="#表情符号-Emoji" class="headerlink" title="表情符号 Emoji"></a>表情符号 Emoji</h3><p>支持大部分标准的表情符号，可使用输入法直接输入，也可手动输入字符格式。通过输入 <code>:</code> 触发自动完成，可在个人设置中<a href="https://hacpai.com/settings/function" target="_blank" rel="noopener">设置常用表情</a>。</p>
<h4 id="一些表情例子"><a href="#一些表情例子" class="headerlink" title="一些表情例子"></a>一些表情例子</h4><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relieved:<br>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :anger:</p>
<h3 id="大标题-Heading-3"><a href="#大标题-Heading-3" class="headerlink" title="大标题 - Heading 3"></a>大标题 - Heading 3</h3><p>你可以选择使用 H1 至 H6，使用 ##(N) 打头。建议帖子或回帖中的顶级标题使用 Heading 3，不要使用 1 或 2，因为 1 是系统站点级，2 是帖子标题级。</p>
<blockquote>
<p>NOTE: 别忘了 # 后面需要有空格！</p>
</blockquote>
<h4 id="Heading-4"><a href="#Heading-4" class="headerlink" title="Heading 4"></a>Heading 4</h4><h5 id="Heading-5"><a href="#Heading-5" class="headerlink" title="Heading 5"></a>Heading 5</h5><h6 id="Heading-6"><a href="#Heading-6" class="headerlink" title="Heading 6"></a>Heading 6</h6><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![alt 文本](http:&#x2F;&#x2F;image-path.png)</span><br><span class="line">![alt 文本](http:&#x2F;&#x2F;image-path.png &quot;图片 Title 值&quot;)</span><br></pre></td></tr></table></figure>

<p>支持复制粘贴直接上传。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*    **strong**</span><br><span class="line">_emphasize_    __strong__</span><br><span class="line">var a &#x3D; 1</span><br></pre></td></tr></table></figure>

<h4 id="语法高亮支持"><a href="#语法高亮支持" class="headerlink" title="语法高亮支持"></a>语法高亮支持</h4><p>如果在 ``` 后面跟随语言名称，可以有语法高亮的效果哦，比如:</p>
<h5 id="演示-Go-代码高亮"><a href="#演示-Go-代码高亮" class="headerlink" title="演示 Go 代码高亮"></a>演示 Go 代码高亮</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello, 世界"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="演示-Java-高亮"><a href="#演示-Java-高亮" class="headerlink" title="演示 Java 高亮"></a>演示 Java 高亮</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: 语言名称支持下面这些: <code>ruby</code>, <code>python</code>, <code>js</code>, <code>html</code>, <code>erb</code>, <code>css</code>, <code>coffee</code>, <code>bash</code>, <code>json</code>, <code>yml</code>, <code>xml</code> …</p>
</blockquote>
<h3 id="有序、无序、任务列表"><a href="#有序、无序、任务列表" class="headerlink" title="有序、无序、任务列表"></a>有序、无序、任务列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul>
<li>Java<ul>
<li>Spring<ul>
<li>IoC</li>
<li>AOP</li>
</ul>
</li>
</ul>
</li>
<li>Go<ul>
<li>gofmt</li>
<li>Wide</li>
</ul>
</li>
<li>Node.js<ul>
<li>Koa</li>
<li>Express</li>
</ul>
</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol>
<li>Node.js<br>1.1. Express<br>1.2. Koa<br>1.3. Sails</li>
<li>Go<br>2.1. gofmt<br>2.2. Wide</li>
<li>Java<br>3.1. Latke<br>3.2. IDEA</li>
</ol>
<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 发布 Sym</li>
<li><input checked="" disabled="" type="checkbox"> 发布 Solo</li>
<li><input disabled="" type="checkbox"> 预约牙医</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>如果需要展示数据什么的，可以选择使用表格。</p>
<table>
<thead>
<tr>
<th>header 1</th>
<th>header 3</th>
</tr>
</thead>
<tbody><tr>
<td>cell 1</td>
<td>cell 2</td>
</tr>
<tr>
<td>cell 3</td>
<td>cell 4</td>
</tr>
<tr>
<td>cell 5</td>
<td>cell 6</td>
</tr>
</tbody></table>
<h3 id="隐藏细节"><a href="#隐藏细节" class="headerlink" title="隐藏细节"></a>隐藏细节</h3><details>
<summary>Summary</summary>
Details
</details>

<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>留空白的换行，将会被自动转换成一个段落，会有一定的段落间距，便于阅读。</p>
<p>请注意后面 Markdown 源代码的换行留空情况。</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>$$a^2 + b^2 = \color{red}c^2$$</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Every minute</span><br><span class="line">        John--&gt;Alice: Great!</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2019-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2019-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/Network/%E5%81%87%E7%8C%AA%E5%A5%97%E5%A4%A9%E4%B8%8B%E7%AC%AC%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/Network/%E5%81%87%E7%8C%AA%E5%A5%97%E5%A4%A9%E4%B8%8B%E7%AC%AC%E4%B8%80/" class="post-title-link" itemprop="url">科学上网（王哥笔记）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-17 11:23:10" itemprop="dateCreated datePublished" datetime="2018-12-17T11:23:10+08:00">2018-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-16 10:36:37" itemprop="dateModified" datetime="2020-05-16T10:36:37+08:00">2020-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>小王哥笔记</p>
</blockquote>
<p>0.0 怎么实现公司翻墙的</p>
<p>0.0 两个机器一个跑ssserver一个跑sslocal或者下载两个shadowsocket（比如一个python版一个go版）就可以在一个机器上运行ssserver+sslocal从而可以实现不用密码连接ss。（通过sslocal监听0.0.0.0）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat start_ss.sh </span><br><span class="line">ssserver -c /etc/shadowsocket-server.json  -d start</span><br><span class="line">nohup /root/bin/shadowsocks-local -c /etc/ss-local.json &amp;</span><br></pre></td></tr></table></figure>



<p>==翻墙后续2：==</p>
<p><strong>GFW（Great Firewall of China，中国国家防火墙）</strong><br>GFW一旦发现数据包中有敏感信息，就会伪造RST数据包，分别发送给连接双方。</p>
<p>场景： 一个国外服务器安装了ssserver和sslocal，实现了socket5代理，现在想再安装Privoxy将socket代理转换成http代理。</p>
<p>问题： 在ss服务器上安装了Privoxy，其他linux服务器配置了<code>http_proxy</code>无法翻墙.</p>
<p>  但是访问<code>ip.sb</code>已经显示使用代理IP且国内网站可以访问。但是一访问外网就GG</p>
<p>思路：–</p>
<ul>
<li>各种瞎比改配置，但是呢实际配置就两行玩不出花来</li>
</ul>
<ul>
<li><p>抓包：发现了很多的RST数据包即:<code>TCP Retranmission</code> ,且服务器上有很多非正常状态的tcp连接<code>tcp    SYN-RECV</code></p>
<p>但我不知道，怎么解决啊</p>
<p>这时，机智的小董一言点破了我</p>
<blockquote>
<p>因为你的SERVER已经转换成http协议了，公网上防火墙检测到http有敏感数据然后就伪造了RST包。</p>
<p>所以你试试中间公网传输用socks，在客户端进行协议转换。即</p>
<p>再要翻墙的机器上安装sslocal+privoxy。666</p>
</blockquote>
</li>
</ul>
<p>结果： 问题完美解决。</p>
<p>就是小董的猜测，GFW检测到HTTP包的敏感信息，所以给我拦截了就出现了 TCP RET。详细了解下TCP状态。</p>
<p>西津的Privoxy为什么全公司都能用啊。<strong>因为，</strong> 全公司的机器都在内网…出去的时候走的还是Sokcet5协议…  原来如此。</p>
<h2 id="Linux中使用ShadowSocks-Privoxy代理"><a href="#Linux中使用ShadowSocks-Privoxy代理" class="headerlink" title="Linux中使用ShadowSocks+Privoxy代理"></a>Linux中使用ShadowSocks+Privoxy代理</h2><h4 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h4><p>A fast tunnel proxy that helps you bypass firewalls.</p>
<p>Features:</p>
<ul>
<li>TCP &amp; UDP support</li>
<li>User management API</li>
<li>TCP Fast Open</li>
<li>Workers and graceful restart</li>
<li>Destination IP blacklist</li>
</ul>
<p>shadowsocks 有 libev、python、go 几个主要分支（ssr 不在讨论范畴内），这里推荐使用广泛的两个： libev、python。<br>python 版的特点是没有 ss-redir、ss-tunnel，并且需要依赖 python 环境；libev 则是使用 C 语言开发的，性能比较好。</p>
<p><a href="https://www.zfl9.com/ss-local.html" target="_blank" rel="noopener">https://www.zfl9.com/ss-local.html</a> </p>
<p>浏览器要配置socks5代理(或者是配置系统socks5代理, 让浏览器走系统代理), 这时候浏览器发起http请求会被改写成socks5请求(估计浏览器内置了 socks5 客户端), 这个 socks5 客户端要先和 shadowsocks local 端进行握手, 客户端先发送握手包, 这个是握手包的每一个字节的解释.<a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/SOCKS</a></p>
<p><img src="https://raw.githubusercontent.com/bingo3d2y/images/master/MarkDown/shadowsock.png" alt="shadowsocket"></p>
<p>0.0 好图</p>
<p>####Install</p>
<p>Debian / Ubuntu:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br><span class="line">0.0 安装过程不定出现什么问题，具体问题具体百度。</span><br></pre></td></tr></table></figure>

<p>CentOS:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure>

<p><em>shadowsocks安装时是不分客户端还是服务器端的, 只不过安装后有两个脚本一个是sslocal代表以客户端模式工作，一个是ssserver代表以服务器端模式工作</em></p>
<h4 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h4><p>You can use a configuration file instead of command line arguments.</p>
<p>使用配置文件可以避免每次启动服务时使用这么多参数.</p>
<p><code>sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</code></p>
<p>Create a config file <code>/etc/shadowsocks.json</code>. Example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"server_ip"</span>,  //可以是本机，也可以是其运行了ssserver的机器</span><br><span class="line">    <span class="string">"server_port"</span>:8388,</span><br><span class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:22,      <span class="comment">## 默认是1080。改成22 啊我真是个天才，就是被人扫到这个端口也没事。</span></span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"mypassword"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:300,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>, //加密算法，不同的加密算法对python的版本要求不一样。这个版本方法实用py2.7</span><br><span class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explanation of the fields:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Explanation</th>
</tr>
</thead>
<tbody><tr>
<td>server</td>
<td>the address your server listens</td>
</tr>
<tr>
<td>server_port</td>
<td>server port</td>
</tr>
<tr>
<td>local_address</td>
<td>the address your local listens</td>
</tr>
<tr>
<td>local_port</td>
<td>local port</td>
</tr>
<tr>
<td>password</td>
<td>password used for encryption</td>
</tr>
<tr>
<td>timeout</td>
<td>in seconds</td>
</tr>
<tr>
<td>method</td>
<td>default: “aes-256-cfb”, see <a href="https://github.com/shadowsocks/shadowsocks/wiki/Encryption" target="_blank" rel="noopener">Encryption</a></td>
</tr>
<tr>
<td>fast_open</td>
<td>use <a href="https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open" target="_blank" rel="noopener">TCP_FASTOPEN</a>, true / false<br />（echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 这个选项需要配合内核参数）</td>
</tr>
<tr>
<td>workers</td>
<td>number of workers, available on Unix/Linux</td>
</tr>
</tbody></table>
<p>To run in the foreground:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>

<p>To run in the background:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>

<p>0.0 运行 ssserver 运行起来后，8138端口会被监听（sslocal运行时才会监听1080端口）。</p>
<p>麻痹咯– 怪不得py的<code>sslocal</code> 在<code>ssserver</code>启动之后总会报错，草。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@DoDo:~<span class="comment"># sslocal  -c /etc/ss-local-3.json -d start  </span></span><br><span class="line">INFO: loading config from /etc/ss-local-3.json</span><br><span class="line">2018-06-29 07:45:51 INFO     loading libcrypto from libcrypto.so.1.0.0</span><br><span class="line">2018-06-29 07:45:51 ERROR    already started at pid 3123</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从下面可以发现，这个3123是ssserver的进程号...</span></span><br><span class="line">root@DoDo:~<span class="comment"># ps -ef |grep sha|grep -v grep </span></span><br><span class="line">root      3123     1  0 Apr29 ?        00:47:05 /usr/bin/python /usr/<span class="built_in">local</span>/bin/ssserver -c /etc/shadowsocket-server.json -d start</span><br><span class="line"></span><br><span class="line"><span class="comment">##github的issue大神</span></span><br><span class="line">https://github.com/shadowsocks/shadowsocks/issues/235</span><br><span class="line">Use --pid-file and --<span class="built_in">log</span>-file to specify different locations <span class="keyword">for</span> pid and <span class="built_in">log</span> files.</span><br><span class="line"></span><br><span class="line"><span class="comment">### 最正确的启动姿势</span></span><br><span class="line">$ sslocal  -c /etc/ss-local-2.json -d start   --pid-file=/run/shadowsocklocal.pid</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>

<p>end</p>
<blockquote>
<p>ssserver 和 sslocal 有什么区别呢？</p>
<p>0.0 辣鸡，明白上面的，以后不需要下载go版的sslocal了</p>
<p>==哈哈哈，区别是client连接用sslocal不需要密码==</p>
<p>PS：我简直是个天才啊，sslocal的local_port设成<code>22</code>啊，我真的是个天才。</p>
<p>ssserver是server，做shadowsocket服务器，必须是能访问外网的服务器。</p>
<p>sslocal类似是client或者是proxy_server ,它不一定要能访问外网但一定要能连接ssserver。</p>
<p>哈哈哈，所以一个能访问外网的机器既可以运行ssserver和sslocal，但是不能访问外网的机器就只能运行sslocal</p>
<p>0.0 理当如此。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root       553     1  0 10:30 ?        00:00:00 /usr/bin/python /usr/<span class="built_in">local</span>/bin/ssserver -c /etc/shadowsocket-server.json -d start</span><br><span class="line">root       596   485  0 10:33 pts/1    00:00:00 /root/bin/shadowsocks-local -c /etc/ss-local.json</span><br><span class="line">0.0 go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</span><br><span class="line">go 语言写的好屌啊，下载过来就能用。</span><br><span class="line"></span><br><span class="line">root@bingo:~<span class="comment"># cat /etc/ss-local.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"45.32.69.51"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:8388,</span><br><span class="line">    <span class="string">"local_address"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:22,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"#@bingo#"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:300,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>, </span><br><span class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">root@bingo:~<span class="comment"># cat /etc/shadowsocket-server.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"45.32.69.51"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:8388,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"#@bingo#"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:300,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>, </span><br><span class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<p>shadowsocket 提供的 socks5 代理，就必须让应用程序使用 socks5 协议与之通信。但是很可惜，除了部分浏览器、软件直接支持 socks5 协议外，其它的都只支持 http 代理。比如，docker。</p>
<p>因此，我们需要借助 privoxy 来将 http 代理协议转换为 socks5 代理协议，与ss服务 进行通信。</p>
<p>shadowsocks是非常流行的一个代理工具，其原理非常简单。</p>
<ul>
<li>客户端服务器预共享密码</li>
<li>本地socks5 proxy server</li>
<li>软件/浏览器配置本地socks代理</li>
<li>本地socks server把数据包装，AES256加密，发送到远程服务器</li>
<li>远程服务器解密，转发给对应的服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app =&gt; <span class="built_in">local</span> socks server(encrypt) =&gt; shadowsocks server(decrypt) =&gt; real host</span><br><span class="line"></span><br><span class="line">app &lt;= (decrypt) <span class="built_in">local</span> socks server &lt;= (encrypt) shadowsocks server &lt;= real host</span><br></pre></td></tr></table></figure>

<p>其它的一些东东：</p>
<ul>
<li>一个端口一个密码，没有用户的概念</li>
<li>支持多个worker并发</li>
<li>协议简单，比socks协议还要简单，抽取了socks协议的部分</li>
</ul>
<p>公司电脑应用：==我感到神奇的地方就在这里，不需要密码，难道连sslocal不需要password？？？==</p>
<p>情景模式里面：</p>
<p>shadowsocks 有两种使用姿势：</p>
<ul>
<li><p><code>ss-local + privoxy</code>：使用 privoxy 作为前端的 http 代理（支持 CONNECT），可选择全局、gfwlist 两种方式；</p>
<blockquote>
<p><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p>
<p><code>gfwlist</code>：gfwlist 就是一个包含了几乎所有被墙域名的列表，因此，使用这种模式只会让被墙的网站走代理；但是很多国外没被墙的域名还是走的直连，因此访问国外未墙网站的时候速度依旧很慢，甚至出现连接超时的情况；</p>
<p>0.0 这个gfwlist 有广大网友在提交。</p>
</blockquote>
</li>
<li><p><code>ss-redir + iptables</code>：支持代理所有 TCP、UDP 流量（本机 UDP 除外），可选择全局、绕过大陆地址两种方式。</p>
<blockquote>
<p><code>绕过大陆地址</code>：顾名思义，只有发往大陆地址的流量不会走代理，其它的不管有没有被墙，统统走代理上网；这样就不会出现 gfwlist 模式的国外未墙网站访问慢的问题了。我个人建议使用这种模式。</p>
</blockquote>
</li>
</ul>
<h2 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h2><p>前面说了，shadowsocket是Soket5协议（有些软件不支持，且需要ss client 0.0），所以需要privoxy将Socket协议的代理转换成http代理。即今天主角：<code>sslocal+privoxy</code>  也是我们公司的模式：</p>
<p>国外服务器(185.3.95.61)  –&gt;  sslocal(192.168.9.12) –&gt;  privoxy(10.212.132.9)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### sslocal(192.168.9.12)</span></span><br><span class="line">cat /etc/shadowsocks/config_frank.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"185.3.95.61"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:9091,</span><br><span class="line">    <span class="string">"local_address"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:3128,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"5566@hell05a"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:600,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">ps -ef |grep <span class="built_in">local</span></span><br><span class="line">root     12697 12653  0 19:27 pts/0    00:00:00 grep --color=auto <span class="built_in">local</span></span><br><span class="line">root     16467     1  0 Nov06 ?        00:18:31 /usr/<span class="built_in">local</span>/bin/ss-local -c /etc/shadowsocks/config_frank.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### privoxy 10.212.132.9</span></span><br><span class="line">cat /etc/privoxy/config</span><br><span class="line">confdir /etc/privoxy</span><br><span class="line">logdir /var/<span class="built_in">log</span>/privoxy</span><br><span class="line">logfile logfile</span><br><span class="line">actionsfile match-all.action </span><br><span class="line">actionsfile default.action   <span class="comment"># Main actions file</span></span><br><span class="line">actionsfile user.action      <span class="comment"># User customizations</span></span><br><span class="line">filterfile default.filter</span><br><span class="line"><span class="comment"># filterfile user.filter      # User customizations</span></span><br><span class="line">listen-address  0.0.0.0:1080</span><br><span class="line">toggle  1</span><br><span class="line"><span class="built_in">enable</span>-remote-toggle  1</span><br><span class="line"><span class="built_in">enable</span>-remote-http-toggle  0</span><br><span class="line"><span class="built_in">enable</span>-edit-actions 1</span><br><span class="line">enforce-blocks 0</span><br><span class="line">buffer-limit 4096</span><br><span class="line"><span class="comment"># enable-proxy-authentication-forwarding 0</span></span><br><span class="line">forwarded-connect-retries  0</span><br><span class="line">accept-intercepted-requests 0</span><br><span class="line">allow-cgi-request-crunching 0</span><br><span class="line">split-large-forms 0</span><br><span class="line">keep-alive-timeout 300</span><br><span class="line">socket-timeout 300</span><br><span class="line"><span class="comment"># tolerate-pipelining 1</span></span><br><span class="line"><span class="comment"># permit-access 10.199.134.0/24</span></span><br><span class="line">forward-socks5 / 192.168.9.12:3128 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /etc/privoxy/config|grep -v  ^#   0.0 这个是默认配置文件上面是西津的，好像西津没改多少</span></span><br><span class="line">user-manual /usr/share/doc/privoxy/user-manual</span><br><span class="line">confdir /etc/privoxy</span><br><span class="line">logdir /var/<span class="built_in">log</span>/privoxy</span><br><span class="line">actionsfile match-all.action <span class="comment"># Actions that are applied to all sites and maybe overruled later on.</span></span><br><span class="line">actionsfile default.action   <span class="comment"># Main actions file</span></span><br><span class="line">actionsfile user.action      <span class="comment"># User customizations</span></span><br><span class="line">filterfile default.filter</span><br><span class="line">filterfile user.filter      <span class="comment"># User customizations</span></span><br><span class="line">logfile logfile</span><br><span class="line">listen-address  localhost:8118</span><br><span class="line">toggle  1</span><br><span class="line"><span class="built_in">enable</span>-remote-toggle  0</span><br><span class="line"><span class="built_in">enable</span>-remote-http-toggle  0</span><br><span class="line"><span class="built_in">enable</span>-edit-actions 0</span><br><span class="line">enforce-blocks 0</span><br><span class="line">buffer-limit 4096</span><br><span class="line"><span class="built_in">enable</span>-proxy-authentication-forwarding 0</span><br><span class="line">      1336  forward-socks5t   /               127.0.0.1:1080 .</span><br><span class="line">forwarded-connect-retries  0</span><br><span class="line">accept-intercepted-requests 0</span><br><span class="line">allow-cgi-request-crunching 0</span><br><span class="line">split-large-forms 0</span><br><span class="line">keep-alive-timeout 5</span><br><span class="line">tolerate-pipelining 1</span><br><span class="line">socket-timeout 300</span><br><span class="line"></span><br><span class="line">0.0 哈哈哈，原来西津也就是换了个ip地址啊哈哈哈，他没有我想的那么神。</span><br></pre></td></tr></table></figure>



<p>docker 应用及Linux 系统：（docker 不支持socket协议）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/systemd/system/docker.service.d/20-proxy.conf </span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"no_proxy=localhost,127.0.0.1,10.199.134.11,hub.servyou.com.cn,reg.servyou.com.cn"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://10.212.132.9:1080"</span></span><br><span class="line"><span class="comment">## Linux  系统翻墙</span></span><br><span class="line">公有云代理配置；<span class="built_in">export</span> https_proxy=https://192.168.120.17:3128</span><br><span class="line">专有云代理配置：<span class="built_in">export</span> https_proxy=https://10.98.101.1:3128  </span><br><span class="line">0.0 声明一个环境变量就行。不过要注意，http和https都要申请</span><br></pre></td></tr></table></figure>



<h2 id="优化-卧槽开了速度贼快"><a href="#优化-卧槽开了速度贼快" class="headerlink" title="优化(卧槽开了速度贼快)"></a>优化(卧槽开了速度贼快)</h2><p>BBR 目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 效果并不比[速锐][<a href="https://github.com/91yun/serverspeeder]差、" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder]差、</a></p>
<p><a href="http://hengyunabc.github.io/something-about-science-surf-the-internet/" target="_blank" rel="noopener">http://hengyunabc.github.io/something-about-science-surf-the-internet/</a></p>
<p><a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95</a></p>
<h2 id="Debian-8-Ubuntu-14（Centos的自己百度或看原网址）"><a href="#Debian-8-Ubuntu-14（Centos的自己百度或看原网址）" class="headerlink" title="Debian 8 / Ubuntu 14（Centos的自己百度或看原网址）"></a>Debian 8 / Ubuntu 14（Centos的自己百度或看原网址）</h2><ul>
<li>下载最新内核,最新内核查看<a href="http://kernel.ubuntu.com/~kernel-ppa/mainline" target="_blank" rel="noopener">这里</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v4.10.17&#x2F;linux-image-4.10.17-041017-generic_4.10.17-041017.201705201051_amd64.deb</span><br></pre></td></tr></table></figure>

<ul>
<li>安装内核</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i linux-image-4.*.deb</span><br></pre></td></tr></table></figure>

<ul>
<li>删除旧内核(可选)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep linux-image </span><br><span class="line">apt-get purge 旧内核</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 grub 系统引导文件并重启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="开启bbr"><a href="#开启bbr" class="headerlink" title="开启bbr"></a>开启bbr</h2><p>开机后 <code>uname -r</code> 看看是不是内核 &gt;= 4.9</p>
<p>执行 <code>lsmod | grep bbr</code>，如果结果中没有 <code>tcp_bbr</code> 的话就先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe tcp_bbr</span><br><span class="line">echo &quot;tcp_bbr&quot; &gt;&gt; &#x2F;etc&#x2F;modules-load.d&#x2F;modules.conf</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc&#x3D;fq&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<p>保存生效<br><code>sysctl -p</code></p>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>

<p>如果结果都有 <code>bbr</code>, 则证明你的内核已开启 bbr</p>
<p>执行 <code>lsmod | grep bbr</code>, 看到有 tcp_bbr 模块即说明 bbr 已启动</p>
<p>[<a href="https://github.com/91yun/serverspeeder]" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder]</a>:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/Network/%E7%88%AC%E5%A2%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/Network/%E7%88%AC%E5%A2%99/" class="post-title-link" itemprop="url">学习ssr爬墙与总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-17 11:23:10" itemprop="dateCreated datePublished" datetime="2018-12-17T11:23:10+08:00">2018-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-15 18:59:54" itemprop="dateModified" datetime="2020-05-15T18:59:54+08:00">2020-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习ssr爬墙与总结"><a href="#学习ssr爬墙与总结" class="headerlink" title="学习ssr爬墙与总结"></a>学习ssr爬墙与总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    每次下载东西，都要呼叫我王哥，而我自己则傻傻地坐在电脑前等待王哥喂屎，不够香。我想，自己扒拉出来的应该更有味道，于是我更加稳当地坐在了小板凳上。</p>
<h2 id="弱鸡扫盲"><a href="#弱鸡扫盲" class="headerlink" title="弱鸡扫盲"></a>弱鸡扫盲</h2><p>什么都不懂，什么都不知道，一个没见过世面的宁波养猪场二组技术员开始了搜狗百科。</p>
<h3 id="什么是SOCKS"><a href="#什么是SOCKS" class="headerlink" title="什么是SOCKS"></a>什么是SOCKS</h3><blockquote>
<p>摘自： <a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/SOCKS</a></p>
</blockquote>
<p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”SOCKetS”的缩写。</p>
<p>当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。</p>
<h4 id="与HTTP代理的对比"><a href="#与HTTP代理的对比" class="headerlink" title="与HTTP代理的对比"></a>与HTTP代理的对比</h4><p><strong>SOCKS</strong>：Bill希望通过互联网与Jane沟通，但他们的网络之间存在一个防火墙，Bill不能直接与Jane沟通。所以，Bill连接到他的网络上的SOCKS代理，告知它他想要与Jane创建连接；SOCKS代理打开一个能穿过防火墙的连接，并促进Bill和Jane之间的通信。</p>
<p><strong>HTTP</strong>：Bill希望从Jane的Web服务器下载一个网页。Bill不能直接连接到Jane的服务器，因为在他的网络上设置了防火墙。为了与该服务器通信，Bill连接到其网络的HTTP代理。他的网页浏览器与代理通信的方式与他直接连接Jane的服务器的方式相同；也就是说，网页浏览器会发送一个标准的HTTP请求头。HTTP代理连接到Jane的服务器，然后将Jane的服务器返回的任何数据传回Bill。</p>
<h4 id="GFW"><a href="#GFW" class="headerlink" title="GFW"></a>GFW</h4><p>中国国家防火墙，一旦发现数据包中有敏感信息，就会伪造RST数据包，分别发送给连接双方。</p>
<blockquote>
<p>摘自：<a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E</a></p>
</blockquote>
<p><strong>原理</strong>：防火长城对所有经过骨干出口路由的在UDP的53端口上的域名查询进行IDS入侵检测，一经发现与黑名单关键词相匹配的域名查询请求，防火长城会马上伪装成目标域名的解析服务器给查询者返回虚假结果。由于通常的域名查询没有任何认证机制，而且域名查询通常基于的UDP协议是无连接不可靠的协议，查询者只能接受最先到达的格式正确结果，并丢弃之后的结果。用户若改用TCP在53端口上进行DNS查询，虽然不会被防火长城污染，但可能会遭遇连接重置，导致无法获得目标网站的IP地址。</p>
<p>ps: 看不懂原理是在搞什么飞机，先搬过来吧。</p>
<h3 id="科学上网之Shadowsocks"><a href="#科学上网之Shadowsocks" class="headerlink" title="科学上网之Shadowsocks"></a>科学上网之Shadowsocks</h3><p>​    原来一直不明白它的原理，多亏了王哥的神作，在我看了几遍之后，才得以稍稍了解其原理。</p>
<blockquote>
<p>A fast tunnel proxy that helps you bypass firewalls.</p>
<p>Features:</p>
<ul>
<li>TCP &amp; UDP support</li>
<li>User management API</li>
<li>TCP Fast Open</li>
<li>Workers and graceful restart</li>
<li>Destination IP blacklist</li>
</ul>
</blockquote>
<p>目前有 <code>libev</code>、<code>python</code>、<code>go</code>几个主要分支，之后的实践我只是使用了go。</p>
<p><strong>王哥</strong>：浏览器要配置<code>socks5</code>代理(或者是配置系统<code>socks5</code>代理, 让浏览器走系统代理), 这时候浏览器发起<code>http</code>请求会被改写成<code>socks5</code>请求, 这个 <code>socks5</code> 客户端要先和 <code>shadowsocks local</code> 端进行握手, 客户端先发送握手包（具体想要了解的可以看上面的<code>socks</code>）。</p>
<p>其原理：</p>
<ul>
<li>客户端服务器预共享密码</li>
<li>本地socks5 proxy server</li>
<li>软件/浏览器配置本地socks代理</li>
<li>本地socks server把数据包装，加密，发送到远程服务器</li>
<li>远程服务器解密，转发给对应的服务器</li>
</ul>
<p>我又看了，给<a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="noopener">非专业人士看的<code>Shadowsocks</code>简介</a>，真香。</p>
<h2 id="搭建（go版本）"><a href="#搭建（go版本）" class="headerlink" title="搭建（go版本）"></a>搭建（go版本）</h2><blockquote>
<p>​    shadowsocks-go is a lightweight tunnel proxy which can help you get through firewalls.</p>
<p>​      <a href="https://github.com/shadowsocks/shadowsocks-go" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-go</a></p>
</blockquote>
<h3 id="买VPS"><a href="#买VPS" class="headerlink" title="买VPS"></a>买VPS</h3><p>古人云：运维不好，对象难找；英语不好，冲浪难搞。不无其中的道理：运维不好；又在买vultr时说好的送25刀，结果，也没送。。。</p>
<p><img src="./images/%E7%88%AC%E5%A2%9901.jpeg" alt=""></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="go环境"><a href="#go环境" class="headerlink" title="go环境"></a>go环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install golang -y</span><br></pre></td></tr></table></figure>

<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> on server</span></span><br><span class="line">go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> on client</span></span><br><span class="line">go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</span><br></pre></td></tr></table></figure>

<p>在一台机器上安装了<code>ssserver</code>和<code>sslocal</code>，实现本地用户无需安装客户端且无需密码，在本地实现翻墙:</p>
<p><strong>app  -&gt;  request vultr sslocal(encrypt)  -&gt;  request vultr ssserver (decrypt) -&gt; real host -&gt; response to vultr ssserver(encrypt) -&gt;  response to vultr sslocal(decrypt)  -&gt;  app</strong></p>
<p>需插件<code>SwitchyOmega</code>，后续会说到。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Both the server and client program will look for <code>config.json</code> in the current directory. You can use <code>-c</code> option to specify another configuration file.</p>
<p> Configuration file is in json ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"server_name", </span><br><span class="line">    "server_port":8388, </span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "local_address":"127.0.0.1",</span><br><span class="line">    "password":"barfoo!",</span><br><span class="line">    "method": "aes-128-cfb",</span><br><span class="line">    "timeout":600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Name</th>
<th>ExPLANATION</th>
</tr>
</thead>
<tbody><tr>
<td>server</td>
<td>your server ip or hostname</td>
</tr>
<tr>
<td>server port</td>
<td>server port</td>
</tr>
<tr>
<td>local_port</td>
<td>local socks5 proxy port</td>
</tr>
<tr>
<td>method</td>
<td>encryption method, null by default (table), the following methods are supported: aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, rc4-md5-6, chacha20, salsa20, rc4, table</td>
</tr>
<tr>
<td>password</td>
<td>a password used to encrypt transfer</td>
</tr>
<tr>
<td>timeout</td>
<td>server option, in seconds</td>
</tr>
<tr>
<td>fast_open</td>
<td>use <a href="https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open" target="_blank" rel="noopener">TCP_FASTOPEN</a>, true / false（echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 这个选项需要配合内核参数）</td>
</tr>
<tr>
<td>workers</td>
<td>number of workers, available on Unix/Linux</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>我的配置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入安装好的目录</span></span><br><span class="line">[root@vultr go]# ls</span><br><span class="line">bin  src  sslocal.json  ssserver.json</span><br><span class="line">[root@vultr go]# cat ssserver.json </span><br><span class="line">&#123;</span><br><span class="line">    "server":"vpsIP",</span><br><span class="line">    "server_port":8388,</span><br><span class="line">    "password":"password",</span><br><span class="line">    "method": "aes-128-cfb",</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "fast_open":false</span><br><span class="line">&#125;</span><br><span class="line">[root@vultr go]# cat sslocal.json </span><br><span class="line">&#123;</span><br><span class="line">    "server":"vpsIP",</span><br><span class="line">    "server_port":8388,</span><br><span class="line">    "local_port":22,</span><br><span class="line">    "local_address":"0.0.0.0",</span><br><span class="line">    "password":"password",</span><br><span class="line">    "method": "aes-128-cfb",</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "fast_open":false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr go]#  ./bin/shadowsocks-server -c ssserver.json</span><br><span class="line">2018/12/19 06:44:19 server listening port 8388 ...</span><br><span class="line"></span><br><span class="line">[root@vultr go]# ./bin/shadowsocks-local -c sslocal.json </span><br><span class="line">2018/12/19 06:45:51 available remote server 149.248.21.68:8388</span><br><span class="line">2018/12/19 06:45:51 starting local socks5 server at 0.0.0.0:22 ...</span><br></pre></td></tr></table></figure>

<p>后台运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr go]# nohup ./bin/shadowsocks-server -c ssserver.json &amp;</span><br><span class="line">[root@vultr go]# nohup ./bin/shadowsocks-local -c sslocal.json &amp;</span><br><span class="line"></span><br><span class="line">[root@vultr go]# ps -ef | grep shadowsocks-</span><br><span class="line">root      5293  5189  0 06:49 pts/0    00:00:00 ./bin/shadowsocks-server -c ssserver.json</span><br><span class="line">root      5299  5189  0 06:50 pts/0    00:00:00 ./bin/shadowsocks-local -c sslocal.json</span><br><span class="line">root      5305  5189  0 06:51 pts/0    00:00:00 grep --color=auto shadowsocks-</span><br></pre></td></tr></table></figure>

<p>搭建完毕，如果使用本地ssclient，记得打开对应端口即上述8388的防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=8388/tcp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line">firewall-cmd --remove-port=8388/tcp --permanent</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>本地客户端和chrome插件</p>
<h3 id="本地客户端"><a href="#本地客户端" class="headerlink" title="本地客户端"></a>本地客户端</h3><blockquote>
<p><a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p>
</blockquote>
<p>客户端的在此不多说，记得开启防火墙。</p>
<h3 id="SwitchyOmega的使用"><a href="#SwitchyOmega的使用" class="headerlink" title="SwitchyOmega的使用"></a>SwitchyOmega的使用</h3><blockquote>
<p><a href="https://github.com/FelisCatus/SwitchyOmega" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega</a></p>
</blockquote>
<h4 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h4><p>首先在github上下载<a href="https://github.com/FelisCatus/SwitchyOmega" target="_blank" rel="noopener">插件</a>，或者直接在chrome web store下载<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN" target="_blank" rel="noopener">SwitchyOmega</a>。</p>
<p>​    将下载好的插件添加到扩展程序中，SwitchyOmega支持多种模式：</p>
<ul>
<li>直接连接：不使用任何代理；</li>
<li>系统代理：使用系统客户端模式代理；</li>
<li>proxy：全部访问使用代理；</li>
<li>autoswitch：根据访问自动判断是否需要代理。</li>
</ul>
<h4 id="配置autoswitch模式"><a href="#配置autoswitch模式" class="headerlink" title="配置autoswitch模式"></a>配置autoswitch模式</h4><p><code>autoswitch</code>模式使用非常方便，推荐使用，如果某些网站访问无法正确打开，可以写换到<code>proxy</code>模式。</p>
<p>1）打开chrome，点击右上角的SwitchyOmega插件图标，点击选项；</p>
<p>2）点击左侧的 <code>新建情景模式</code>，根据喜好输入情景模式名称 如：<code>Shadowsocks</code>，类型选择第一个<code>代理服务器</code>。左侧菜单中好像有个情景模式，叫<code>proxy</code>，如果有就不需要新建了可以直接做配置。做如下配置：</p>
<p><img src="./images/%E7%88%AC%E5%A2%9902.png" alt=""></p>
<p>​    可自行配置不代理的地址列表。</p>
<p>3）配置自动切换模式。点击左侧<code>auto switch</code>，规则列表选择<code>AutoProxy</code>，添加规则列表。</p>
<p><img src="./images/%E7%88%AC%E5%A2%9903.png" alt=""></p>
<p>默认情景模式选择<code>直接连接</code>，这样就直接添加上了大多数网站的代理规则，如果遇到未添加的，可以自己再<code>添加条件</code>。</p>
<p><img src="./images/%E7%88%AC%E5%A2%9904.png" alt=""></p>
<p><img src="./images/%E7%88%AC%E5%A2%9905.png" alt=""></p>
<blockquote>
<p><a href="https://github.com/gfwlist/gfwlist" target="_blank" rel="noopener">https://github.com/gfwlist/gfwlist</a></p>
<p>规则列表网址：<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p>
<p>gfwlist 是一个开源的黑名单项目，它由成千上万的网友贡献整理而成的一个包含了几乎所有被墙域名的列表，从而实现被墙的域名自动走代理。</p>
</blockquote>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>通过TCP BBR拥塞控制来进行加速的服务。</p>
<p>BBR 目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 效果并不比速锐差。</p>
<p>​    使用root用户登录，运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>

<p>​    安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。 重启</p>
<p>​    完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令查看内核版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看内核版本</span></span><br><span class="line">uname -r</span><br><span class="line">4.19.10-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行</span></span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回值一般为：</span></span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者为：</span></span><br><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行</span></span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回值一般为：</span></span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行</span></span><br><span class="line">sysctl net.core.default_qdisc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回值一般为：</span></span><br><span class="line">net.core.default_qdisc = fq</span><br></pre></td></tr></table></figure>

<p>执行 <code>lsmod | grep bbr</code>, 看到有 tcp_bbr 模块即说明 bbr 已启动。</p>
<p>注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>
<blockquote>
<p>一键安装最新内核并开启 BBR 脚本：<a href="https://teddysun.com/489.html" target="_blank" rel="noopener">https://teddysun.com/489.html</a></p>
<p>来自Google的TCP BBR拥塞控制算法解析：<a href="https://blog.csdn.net/dog250/article/details/52830576" target="_blank" rel="noopener">https://blog.csdn.net/dog250/article/details/52830576</a></p>
<p>开启TCP BBR拥塞控制算法：<a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    倒腾了两天，蛮开心的，大神数不胜数，站在他们的肩膀上是一件多么令人兴奋的事情。非常感谢我王哥对我的zz问题一一解答。</p>
<p>​    总之，我王哥天下第一！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/JavaScript/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ccbeango">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凹凸豆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/JavaScript/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="post-title-link" itemprop="url">JS的执行环境及作用域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-11 19:44:10" itemprop="dateCreated datePublished" datetime="2018-07-11T19:44:10+08:00">2018-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-27 17:56:53" itemprop="dateModified" datetime="2019-12-27T17:56:53+08:00">2019-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JS的执行环境及作用域"><a href="#JS的执行环境及作用域" class="headerlink" title="JS的执行环境及作用域"></a>JS的执行环境及作用域</h1><blockquote>
<p>摘自《JavaScript高级程序设计》</p>
</blockquote>
<p>​    执行环境（execution context，有时也称为环境）是JS中最为重要的一个概念。<strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
<p>​    每个执行环境都有一个与之关联的<strong>变量对象</strong>（varialbe object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p>
<p>​    全局执行环境是最外围的一个执行环境。根据宿主环境的不同，表示执行环境的对象也不一样，如Web浏览器中是<code>window</code>对象，Node中是<code>global</code>，所有全局变量都是全局对象的属性。</p>
<p>​    某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出时才销毁）。</p>
<p>​    每个函数都有自己的执行环境。当执行进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把执行权返回给之前的执行环境。JS程序中的执行流正式由这个机制控制的。</p>
<p>​    当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途是：==保证对执行环境有权访问的所有变量和函数的有序访问。==作用域的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（activation object）作为变量对象。</p>
<p>​      活动对象在最开始的时候只包含一个变量，即<code>arguments</code>对象。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>​    标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符位置（如果找不到标识符，通常会导致错误发生）。</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(color === <span class="string">"blue"</span>) &#123;</span><br><span class="line">        color = <span class="string">"red"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="string">"blue"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(changeColor());</span><br></pre></td></tr></table></figure>

<p>​    在这个例子中，函数<code>changeColor()</code>的作用域链包含两个对象：它自己的变量对象（其中定义着<code>arguments</code>对象）和全局环境的变量对象。可以在函数内部访问变量<code>color</code>，就是因为可以在这个作用域链中找到它。</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tmpColor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>

<p>​    以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColor()的局部环境。全局环境中有一个变量<code>color</code>和一个函数<code>changeColor()</code>。changeColor()的局部环境中有一个变量<code>anotherColor</code>和一个函数<code>swapColors()</code>，但它也可以访问全局环境中的变量<code>color</code>。swapColors()的局部变量中有一个变量<code>tempColor</code>，该变量只能在这个环境中访问到。无论是全局环境还是changeColor()的局部变量都无权访问<code>tempColor</code>，然而，在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。如图：</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F01.jpg" alt=""></p>
<p>​    上图表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量名和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p>
<p>​    对于这个例子中的<code>swapColors()</code>而言，其作用域中包含3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部环境开始时会现在自己的变量对象中搜索函数名和变量，如果搜索不到再搜索上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局变量对象，也就是诉说，它不能访问swapColors()的环境。</p>
<p><strong>函数参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同。</strong></p>
<h2 id="理解JS的闭包函数"><a href="#理解JS的闭包函数" class="headerlink" title="理解JS的闭包函数"></a>理解JS的闭包函数</h2><p>闭包是指有权访问另一个函数作用域中的函数。</p>
<p>创建闭包的常见方式，就是在一个函数内部创建另一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>value1</code>和<code>value2</code>两行代码时内部函数（一个匿名函数）中的代码，这梁行代码访问了外部函数中的变量<code>propertyName</code>。即使这个内部函数被放回了，而且是在其他地方被调用了，但它仍然可以访问变量<code>propertyName</code>。之所以还能访问这个变量，是因为内部函数的作用域链中包含<code>createComparisonFunction()</code>的作用域。</p>
<p>要搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手。</p>
<p>​    有关如何创建作用域链以及作用域链有什么作用的细节，对于彻底理解闭包至关重要。关于作用域链上面已经讲过，当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后使用<code>arguments</code>和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，······直至作为作用域链终点的全局执行环境。</p>
<p>​    在函数执行过程中，为读取和写入变量的值，就需要在作用域中查找变量。</p>
<hr>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码先定义了<code>compare()</code>函数，然后又在全局作用域中调用了它。当调用<code>compare()</code>时，会创建一个包含<code>arguments</code>、<code>value1</code>、<code>value2</code>的活动对象。全局执行环境的变量对象（result和compare）在<code>compare()</code>执行环境的作用域链中则处于第二位。如下图，包含了上述关系的<code>compare()</code>函数执行时的作用域链。</p>
<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F01.jpg" alt=""></p>
<p>​    后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像<code>compare()</code>函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建<code>compare()</code>函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的<code>[[Scope]]</code>属性中。当调用<code>compare()</code>函数时，会为函数创建一个执行环境，然后通过复制函数的<code>[[Scope]]</code>属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推人执行环境作用域链的前端。对于这个例子中<code>compare()</code>函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，==作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。==</p>
<p>​    无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象)。 但是，闭包的情况又有所不同。</p>
<hr>
<p>​    在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。因 此，在<code>createComparisonFunction()</code>函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数<code>createComparisonFunction()</code>的活动对象。</p>
<p>下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compare = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">const</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ccbeango/blogImages/master/JavaScript/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F03.jpg" alt=""></p>
<p>在匿名函数从<code>createComparisonFunction()</code>中被返回后，它的作用域链被初始化为包含 <code>createComparisonFunction()</code>函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 <code>createComparisonFunction()</code>中定义的所有变量。更为重要的是，<code>createComparisonFunction()</code> 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当<code>createComparisonFunction()</code>函数返回后，其执行环境的作用域链会被销毁，但它的活 动对象仍然会留在内存中；直到匿名函数被销毁后，<code>createComparisonFunction()</code>的活动对象才被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数 </span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 调用函数  </span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</span><br><span class="line"><span class="comment">// 解除对匿名函数的引用，以便释放内存</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>​    首先，创建的比较函数被保存在变量<code>compareNames</code>中。而通过将<code>compareNames</code>设置为等于<code>null</code> 解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域 (除了全局作用域）也都可以安全地销毁了。上图展示了调用<code>compareNames ()</code>的过程中产生的作用域链之间的关系。</p>
<p><strong>注意：</strong>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。虽然像V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。</p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>闭包只能取得包含函数中任何变量的最后一个值。</p>
<p>看下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i; </span><br><span class="line">        &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createFunctions()[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值，即位置<code>0</code>的函数返回<code>0</code>,位置<code>1</code>的函数返回<code>1</code>，以此类推。但实际上，每个函数都返回<code>10</code>。因为每个函数的作用域链中都保存着 <code>createFunctions ()</code>函数的活动对象，所以它们引用的都是同一个变量<code>i</code>。当 <code>createFunctions ()</code>函数返回后，变量<code>i</code>的值是10，此时每个函数都引用着保存变量i的同一个变量 对象，所以在每个函数内部<code>i</code>的值都是10。</p>
<p>使用var声明的变量全局有效，使用let就可以避免这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i; </span><br><span class="line">        &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createFunctions()[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，每次<code>for</code>循环的变量<code>i</code>，都会保存在块级作用域的活动对象中，所以最后输出的是<code>6</code>。</p>
<h3 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h3><p>在ES5中，在比保重使用<code>this</code>对象会导致一些问题。<code>this</code>对象是在运行时基于函数的执行环境绑定的：在全局中，<code>this</code>是全局执行环境对象，而当函数被作为某个对象的方法调用时，<code>this</code>等于那个对象。</p>
<p>来看看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125; &#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">// "The Window" (在非严格模式下)</span></span><br><span class="line"><span class="comment">// Cannot read property 'name' of undefined (在严格模式下this的全局对象指向是undefined，禁止this指向全局对象)</span></span><br></pre></td></tr></table></figure>

<p>上面代码<code>getNameFunc()</code>返回一个匿名函数，而匿名函数又返回<code>this.name</code>，然而，例子的返回字符串是The Window，即全局name变量的值。前面提到过，==每个函数在被调用的时候会自动取得两个特殊变量：<code>this</code>和<code>arguments</code>。==内函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。解决方法可以把作用域中的<code>this</code>对象保存在一个闭包能够访问的变量里，就可以让闭包访问该对象了；或者使用ES6的箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// My Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object2.getNameFunc()()); <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ccbeango</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ccbeango</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
